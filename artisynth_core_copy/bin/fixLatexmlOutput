#!/usr/bin/perl 

# A simple filter that fixes some problems with the xhtml generated by
# LaTeXML (or more precisely, latexmlpost).

use open ':encoding(utf8)'; # these lines ensure that the stdin will
use open ':std';            # be interpretted as utf-8

sub printUsageAndExit {
    print "Usage: fixLatexmlOutput [-xhtml] [<infile>]\n";
    exit 1;
}

$xhtml = 0;
while ($_ = $ARGV[0]) {
    shift;
    if ($_ eq "-xhtml") {
	$xhtml = 1;
    }
    elsif (!defined $infileName) {
        $infileName = $_;
    }
    else {
	printUsageAndExit();
    } 
}

my $INPUT;
if (defined $infileName) {
    open ($INPUT, $infileName) or die "Can't open $infileName: $!\n";
}
else {
    $INPUT = *STDIN;
}

$prevline = "";
while (<$INPUT>) {
    $line = $_;
    # add a virtual space to blank lines in lstlisting output, so that
    # they actually show up as blank lines
    if ($xhtml) {
       $line =~ s/(<td class="td"><span .*class="text lstline"\/>)<\/td>/\1\&nbsp;<\/td>/;  
    }
    else {
       $line =~ s/(<td class="td"><span .*class="text lstline"><\/span>)<\/td>/\1\&nbsp;<\/td>/;  
    }
    # replace unicode ellipsis character with ...
    $line =~ s/\x{2026}/.../g;
    # replace unicode left quotes with ``
    #
    # Odd behavior: on SuSE 4.1, perl failed on the expression 
    #  $line =~ s/\x{2018}/`/g;
    # citing Malformed UTF-8 character (fatal). The problem seemed to
    # be related to having two unicode characters appear together. However, 
    # replacing both characters at the same time fixed the problem
    #
    $line =~ s/\x{2018}\x{2018}/``/g;
    # replace unicode right quotes with ''
    $line =~ s/\x{2019}\x{2019}/''/g;
	# replace %5C with backslash
    # $line =~ s/%5C(?=.*\.css)/\//g;
    $line =~ s/%5C(?=.*\.)/\//g;
    # For XHTML: remove newline after <pre> tag in order to prevent
    # extra blank line at the beginning of the block (this is a
    # problem in xhtml, not html).
    if ($xhtml && $line =~ m/<pre class="verbatim typewriter"[^>]*>$/) {
	$prevline = $line;
	chomp($prevline);
    }
    else {
        print $prevline . $line;
	$prevline = "";
    }
}
