package artisynth.core.femmodels.integration;

import artisynth.core.femmodels.FemElement3d;
import artisynth.core.femmodels.FemElement3dBase;
import artisynth.core.femmodels.HexElement;
import artisynth.core.femmodels.PyramidElement;
import artisynth.core.femmodels.TetElement;
import artisynth.core.femmodels.WedgeElement;
import maspack.matrix.Matrix3d;
import maspack.matrix.Point3d;
import maspack.matrix.Vector3d;

/**
 * 
 * Regularly samples from a FEM element by incrementing 
 * natural coordinates within the bounds of an element
 *
 */
public class RegularFemElementSampler implements FemElementSampler {

   private static abstract class RegularFemElementSamplerImpl implements FemElementSampler {
      protected int res;
      protected int s;
      protected int t;
      protected int u;
      FemElement3dBase elem;
      Point3d coord;
      
      public RegularFemElementSamplerImpl(FemElement3d elem, int res) {
         this.res= res;
         s = 0;
         t = 0;
         u = 0;
         coord = new Point3d();
         setElement(elem);
      }
      
      @Override
      public void setElement(FemElement3d elem) {
         this.elem = elem;
         s = 0;
         t = 0;
         u = 0;
         elem.computeVolumes();
      }

      @Override
      public Point3d sample() {
         Point3d out = new Point3d();
         sample(out);
         return out;
      }
      
      protected abstract double icoord(Vector3d coord);
      
      /**
       * Number of unique samples generated by this sampler, 
       * samples will cycle back to the beginning once the
       * number of samples exceeds this.
       * @return number of unique samples
       */
      public abstract int numUniqueSamples();
      
      @Override
      public void sample(Point3d coord, Point3d out) {
         icoord(coord);
         elem.computeLocalPosition(out, coord);
      }
      
      @Override
      public double isample(Point3d coord, Point3d out) {
         double dv = icoord(coord);
         elem.computeLocalPosition(out, coord);
         
         // get scaling w.r.t. coordinates
         Matrix3d J = new Matrix3d();
         elem.computeJacobian (J, coord);
         
         dv = dv*J.determinant()/elem.getVolume();
         
         return dv;
      }
      
      @Override
      public void sample(Point3d pnt) {
         sample(coord, pnt);
      }

   }
   
   public static class RegularTetSampler extends RegularFemElementSamplerImpl {

      public RegularTetSampler(TetElement elem, int res) {
         super(elem, res);
      }

      @Override
      protected double icoord(Vector3d coord) {
         // move to next coordinate
         double h = 0.5/res;
         coord.x = h*(1+2*s);
         coord.y = h*(1+2*t);
         coord.z = h*(1+2*u);
         
         
         // small volume in unit cube
         double dv = 2.0/res/(res+1)/(2*res-1);
         if (s + t + u == res-1) {
            dv = dv/6.0;
            coord.x -= 0.5*h;
            coord.y -= 0.5*h;
            coord.z -= 0.5*h;
         }
         
         if (!elem.coordsAreInside(coord)) {
            // System.out.println("huh?");
            elem.coordsAreInside(coord);
         }
         
         // advance to next coordinate
         s = s + 1;
         if (s + t + u == res) {
            s = 0;
            t = t + 1;
            if (s + t + u == res) {
               s = 0;
               t = 0;
               u = u + 1;
               if (s + t + u == res) {
                  s = 0;
                  t = 0;
                  u = 0;
               }
            }
         }
         
         return dv;
      }
      
      @Override
      public int numUniqueSamples() {
         return (((res*(res+1))/2)*(res+2))/3;
      }
      
   }

   public static class RegularPyramidSampler extends RegularFemElementSamplerImpl {
      public RegularPyramidSampler(PyramidElement elem, int res) {
         super(elem, res);
      }
      
      @Override
      public int numUniqueSamples() {
         return (((res*(res+1))/2)*(2*res+1))/3;
      }

      @Override
      protected double icoord(Vector3d coord) {
         double w = 1.0/(res-u);
         double h = 1.0/res;
         coord.x = w*(1+2*s)-1;
         coord.y = w*(1+2*t)-1;
         coord.z = h*(1+2*u)-1;
         
         double dv = 8.0/res/(res-u)/(res-u);
         
         // advance
         s = s + 1;
         if (s == res - u) { // -u
            s = 0;
            t = t + 1;
            if (t == res - u) { // -u
               s = 0;
               t = 0;
               u = u + 1;
               if (u == res) {
                  s = 0;
                  t = 0;
                  u = 0;
               }
            }
         }
         
         return dv;
      }
   }
   
   public static class RegularWedgeSampler extends RegularFemElementSamplerImpl {
      public RegularWedgeSampler(WedgeElement elem, int res) {
         super(elem, res);
      }

      @Override
      public int numUniqueSamples() {
         return (res*(res+1)/2)*res;
      }
      
      @Override
      protected double icoord(Vector3d coord) {
         double h = 0.5/res;
         
         coord.x = h*(1+2*s);
         coord.y = h*(1+2*t);
         coord.z = 2*h*(1+2*u)-1;
         
         // n*n*(n+1)/2 points, those on edge are half volume
         // n*n*(n-1)/2 regular points, n half points
         // 1 = n*n*(n-1)/2*dv + n*n/2*dv
         double dv = 2.0/res/res/res;
         if (s + t == res-1) {
            dv = dv/2;
            coord.x -= h/3;
            coord.y -= h/3;
         }
         
         // increment
         s = s+1;
         if (s + t == res) {
            s = 0;
            t = t+1;
            if (s + t == res) {
               s = 0;
               t = 0;
               u = u + 1;
               if (u == res) {
                  s = 0;
                  t = 0;
                  u = 0;
               }
            }
         }
         return dv;
      }
   }
   
   public static class RegularHexSampler extends RegularFemElementSamplerImpl {
      public RegularHexSampler(HexElement elem, int res) {
         super(elem, res);
      }
      
      @Override
      public int numUniqueSamples() {
         return res*res*res;
      }

      @Override
      protected double icoord(Vector3d coord) {
         double h = 1.0/res;
         coord.x = h*(1+2*s)-1;
         coord.y = h*(1+2*t)-1;
         coord.z = h*(1+2*u)-1;
         
         double dv = 8.0/res/res/res;
         
         // advance
         s = s + 1;
         if (s == res) {
            s = 0;
            t = t + 1;
            if (t == res) {
               t = 0;
               u = u + 1;
               if (u == res) {
                  u = 0;
               }
            }
         }   
         return dv;
      }
   }
   
   
   private RegularFemElementSamplerImpl impl = null;
   private int res = 0;
   
   public RegularFemElementSampler(int res) {
      this.res = res;
   }
   
   public RegularFemElementSampler(FemElement3d elem, int res) {
      this.res = res;
      setElement(elem);
   }
   
   @Override
   public void setElement(FemElement3d elem) {
      if (elem instanceof HexElement) {
         impl = new RegularHexSampler((HexElement)elem, res);
      } else if (elem instanceof WedgeElement) {
         impl = new RegularWedgeSampler((WedgeElement)elem, res);
      } else if (elem instanceof PyramidElement) {
         impl = new RegularPyramidSampler((PyramidElement)elem, res);
      } else if (elem instanceof TetElement) {
         impl = new RegularTetSampler((TetElement)elem, res);
      } else {
         throw new IllegalArgumentException("Element type not supported: " + elem.getClass() );
      }
   }

   @Override
   public Point3d sample() {
      return impl.sample();
   }

   @Override
   public void sample(Point3d pnt) {
      impl.sample(pnt);
   }

   @Override
   public void sample(Point3d coord, Point3d pnt) {
      impl.sample(coord, pnt);
   }

   @Override
   public double isample(Point3d coord, Point3d pnt) {
      return impl.isample(coord, pnt);
   }
   
   /**
    * Number of unique samples at current resolution, for
    * regularly sampling across entire element 
    * 
    * @return number of unique samples
    */
   public int numUniqueSamples() {
      return impl.numUniqueSamples();
   }
   
   

}
