\documentclass{article}
\usepackage{amsmath}

% Add search paths for input files
\makeatletter
\def\input@path{{../}{../../}{../texinputs/}}
\makeatother

\input{artisynthDoc}

\setcounter{tocdepth}{5}
\setcounter{secnumdepth}{3}

\title{ArtiSynth User Interface Guide}
\author{John Lloyd}
\setpubdate{Last update: Jan 14, 2021}
\iflatexml
\date{}
\fi

%======================================================
% Custom XML language definition and list environment
%     (Sanchez, 20 July 2012)
%======================================================
\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{darkpurple}{rgb}{0.4,0.0,0.4}
\definecolor{cyan}{rgb}{0.0,0.4,0.4}
\lstdefinelanguage{XMLMenu}
{
  showstringspaces=false,
  columns=fullflexible,
  commentstyle=\color{gray}\upshape,
  basicstyle=\ttfamily\color{black},
  morestring=[b]",
  morecomment=[s]{<?}{?>},
  stringstyle=\color{blue},
 % morecomment=[s]{>}{<},
  identifierstyle=\color{darkpurple},
  keywordstyle=\color{cyan},
  morekeywords={xmlns,version,type,xsi,schemaLocation, text, icon, class,
		source, base, view, file, fontname, fontsize, fontstyle, 
		compact} % list your attributes here
}

%\newcommand{\inlineXML}[1]{\lstinline[language=XMLMenu]{#1}}

\newcommand{\openquot}{\iflatexml"\else``\fi}
\newcommand{\closequot}{\iflatexml"\else''\fi}
\newcommand{\quot}[1]{\openquot#1\closequot}

%======================================================

\begin{document}

\maketitle

\iflatexml{\large\pubdate}\fi

\tableofcontents

\section{Introduction}

This manual describes the ArtiSynth user interface, and how it can be
used to edit models and interactively monitor and control their
simulation.

%Within the manual, the location of the ArtiSynth installation
%directory will be denoted by {\tt <ARTISYNTH\_HOME>}

\section{Loading, Simulating and Saving Models}

The first thing an ArtiSynth user is likely to want is to load a
demonstration model, and explore and simulate it.

A number of predefined demonstration models come bundled with the
ArtiSynth distribution. These are generally simple models that
illustrate particular simulation capabilities. More complex
anatomical models, including those used in various research projects,
are available in the separate project {\tt artisynth\_models}, which
must be downloaded separately (see
\href{http://www.artisynth.org/models}{www.artisynth.org/models} 
for instructions).

An ArtiSynth model is defined by a Java class which is a subclass of
the ArtiSynth {\tt RootModel} component. This class builds the model,
serves as the root container for all its components, and implements
the {\tt advance()} method which allows the model to be simulated.

There are several ways to load models.

\subsection{Loading from the Models menu}
\label{LoadingFromModelsMenu}

Some models can be loaded directly using the {\sf Models} menu located
in the ArtiSynth menu bar. By default, this expands to a number of
submenus:

\begin{tabular}{ll}
{\sf Demos} & - all models listed in the file {\tt .demoModels}\\
{\sf All Demos} & - every model found under the package {\tt artisynth.demos}, 
arranged hierarchically
\end{tabular}

In addition, if {\tt artisynth\_models} has also been installed, or if
ArtiSynth otherwise detects the presence of Java packages located
under {\tt artisynth.models}, then the {\sf Models} menu will also
contain:

\begin{tabular}{ll}
{\sf Models} & - all models listed in the file {\tt .mainModels}\\
{\sf All Models} & - every model found under the packages 
{\tt artisynth.models}, arranged hierarchically
\end{tabular}

The files {\tt .demoModels} and {\tt .mainModels} are searched for in
the list of directories specified by the {\tt ARTISYNTH\_PATH}
environment variable (which if not present defaults to the current
directory, the user's home directory, and the ArtiSynth install
directory).

Each submenu expands out to identify a set of models. Selecting
one of the models will cause it to be loaded into ArtiSynth and
displayed in the viewer. Hovering over one of the entries will
display the full classname of the associated {\tt RootModel}.

\begin{sideblock}
It is possible to customize the contents of the {\sf Models} menu; see
Section \ref{CustomizingModelsMenu}.
\end{sideblock}

\subsection{Loading by class path}

As mentioned above, models are defined by subclasses of {\tt
RootModel}.  A model may therefore be loaded into
ArtiSynth by specifying the classname of its {\tt RootModel}.  To do
this, go to the {\sf File} menu and choose {\sf Load from class ...},
which will bring up a dialog that permits you to enter the
classname. The dialog supports expansion using the {\tt <TAB>} key.

It is also possible to use the {\tt -model <classname>} command line
argument to have a model loaded directly into ArtiSynth when it starts
up. For example, when running ArtiSynth using the {\tt artisynth}
command, one may specify
\begin{lstlisting}[]
  artisynth -model artisynth.models.mystuff.TestModel
\end{lstlisting}
Under Eclipse, the {\tt -model} argument may be specified in the {\tt
Arguments} section of the run configuration.

\subsection{Loading from a file}

Finally, it is possible to load a model from a file.  Selecting {\sf
Load model ...} from the {\sf File} menu will bring up a File browser
that lets you select and load a model from an ArtiSynth model file.
ArtiSynth model files are text-based documents that contain a
hierarchical description of all the model's components, and are
typically identified by the extension {\tt .art}.

\begin{sideblock}
When loading a model from a {\tt .art} file, it is necessary to have
all classes associated with that model in the current Java classpath.
This can be an issue when loading files generated by other users using
application-specific Java code. Two possible solutions to this are:
(a) bundling the application-specific code into a {\tt .jar} file and
placing it in the directory {\tt <ARTISYNTH\_HOME>/lib}, or (b) making
sure that the file was saved using only {\tt artisynth\_core}
components, as described in Section \ref{SavingSec}.
\end{sideblock}

\subsection{Reloading a model}

After a model has been loaded by any of the methods described above,
it can be reloaded by selected {\sf Reload model} from the {\sf File}
menu.

\subsection{Simulating a model}
\label{SimulatingSec}

Once a model is loaded, simulation of the model can be started,
paused, single-stepped, or reset using the play controls (Figure
\ref{PlayControlsFig}) located at the upper right of the ArtiSynth
window frame. Play controls are discussed in more detail
in Section \ref{PlayControlsSec}.

Play controls are also available in the ArtiSynth timeline (Section
\ref{TimelineSec}).  Also, hitting the `{\tt p}', `{\tt s}'
and `{\tt r}' keys from within the viewer (Section
\ref{keyShortcutsSec}) can be used to play/pause, single step and
reset the simulation.

\begin{figure}[h]
\begin{center}
\iflatexml
\includegraphics[]{images/playControls}
\else
\includegraphics[width=2.5in]{images/playControls}
\fi
\end{center}
\caption{The ArtiSynth play controls. From left to right: step size
control, current simulation time, and the reset, skip-back,
play/pause, single-step and skip-forward buttons.}%
\label{PlayControlsFig}
\end{figure}

\subsection{Other toolbar controls}

The ArtiSynth application contains a toolbar that runs along the top
of the frame. The right side contains the play controls shown in
Figure \ref{PlayControlsFig}.

When a grid is enabled in the viewer (Section \ref{ViewerGrid}), a
text box appears in the center of the toolbar displaying the current
grid units (Section \ref{GridUnits}).

The left side of the toolbar contains the following buttons:

\begin{tabular}{l l l}
\iflatexml
\includegraphics{images/navpanelIcon}
\else
\includegraphics[width=.33in]{images/navpanelIcon}
\fi
& NavPanel: &
Shows or hides the navigation panel (Section \ref{navPanelSec})\\
\iflatexml
\includegraphics{images/resetState}
\else
\includegraphics[width=.33in]{images/resetState}
\fi
& Reset state: &
Resets the simulation state at time 0 to the current state.\\
\iflatexml
\includegraphics{images/rerender}
\else
\includegraphics[width=.33in]{images/rerender}
\fi
& Rerender: &
Rerenders all viewers and displays.\\
\iflatexml
\includegraphics{images/realtimeEnable}
\else
\includegraphics[width=.33in]{images/realtimeEnable}
\fi
& Enable real-time: &
Toggle which if pressed (the default), forces the simulation to run no faster than real time.
\end{tabular}

\subsection{Saving a model}
\label{SavingSec}

An ArtiSynth model can be saved to a file to be reloaded and used
later.  Selecting {\sf Save model as ...} from the {\sf File} menu
will bring up a dialog that lets you select the name and directory for
the model file (Figure \ref{saveModelDialog:fig}).  If a model file
has already been specified, then one can save to it again by selecting
the {\sf Save model} menu item.  ArtiSynth model files are text-based
and are typically identified by the extension {\tt .art}.

\begin{figure}[h]
\begin{center}
\iflatexml
\includegraphics[]{images/saveModelDialog}
\else
\includegraphics[width=.5\textwidth]{images/saveModelDialog}
\fi
\end{center}
\caption{The save model dialog.}%
\label{saveModelDialog:fig}
\end{figure}

When using the {\sf Save model as ...} menu item, the user may choose
the following options:

\begin{description}

\item[Save waypoint data:] \mbox{}

Causes the state data for any valid waypoints (Section
\ref{waypointsSec}) to be saved in addition to the waypoint locations.
This is optional because a large number of waypoints may significantly
increase the file size for models with a large state sizes.

\item[Core components only:] \mbox{}

Saves only those components which are
present in the main {\tt artisynth\_core} package. Any non-core
components, and any other components which have a hard dependency on
them, will not be written, and the user will be advised of this via a
message dialog.  The root model (Section \ref{hierarchySec}) is saved
as a pure instance of {\tt RootModel}, instead of the
application-specific class that was used to build it. This means that
any properties or class overrides specific to the application root
model class will not be present in the saved model. The advantage to
storing a model using only core components is that it can be loaded by
any other user running that same ArtiSynth version, without needing
access to any application-specific classes.

\end{description}

\subsection{The ArtiSynth working directory}
\label{workingDir:sec}

ArtiSynth maintains the notion of a {\it working directory}, which is
the default directory (or folder, in Windows parlance) under which the
files used to store various types of model information are stored.
This includes model files, as described above, along with other files
such as those used to store waypoints, probe configurations, or probe
data (Section \ref{savingLoadingProbes:sec}).

Chooser dialogs for these files will generally open in the working
directory by default.

The working directory is initialized to the local system directory in
which the ArtiSynth application is started. Once ArtiSynth is running,
it can be set by choosing {\sf Set working dir ...} from the {\sf
File} menu, or by calling
\begin{verbatim}
   ArtisynthPath.setWorkingDir (file)
\end{verbatim}
in code. When a model is saved (Section \ref{SavingSec}), the working
directory is saved with it and restored when the model file is
subsequently loaded.

\section{The Viewer}

The viewer provides interactive graphical rendering of the ArtiSynth
model and permits selection of its components. A viewer is integrated
into the ArtiSynth main frame; additional viewers can be created
if necessary.

\subsection{Viewer Toolbar}

Each viewer is provided with a toolbar (Figure \ref{ViewerToolbarFig}) equipped
with icons for controlling the viewpoint (Section \ref{ViewpointControlSec}) and
clipping planes (Section \ref{ClippingPlanesSec}). The toolbar for the main viewer
appears vertically at the lower left of the main frame, while toolbars
for additional viewers appear horizontally at the top.  Each is an
instance of Java's {\tt JToolBar}, and so can be moved and docked
accordingly.

\begin{figure}[h]
\begin{center}
\iflatexml
\includegraphics[]{images/viewerToolbar}
\else
\includegraphics[width=2.5in]{images/viewerToolbar}
\fi
\end{center}
\caption{The viewer toolbar.}%
\label{ViewerToolbarFig}
\end{figure}

\subsection{Viewpoint control}
\label{ViewpointControlSec}

The viewpoint can be controlled interactively using mouse drag
actions.  On systems with a three-button mouse, this is generally done
using the middle mouse button ({\tt MMB}), in conjunction with the
{\tt SHIFT} and {\tt CTRL} modifier keys:

\begin{description}

\item[MMB] \mbox{}

Rotates the viewpoint about the viewer center point.

\item[MMB + SHIFT] \mbox{}

Translates the viewpoint in a plane perpendicular to the
line of sight.

\item[MMB + CTRL {\it or} mouse WHEEL] \mbox{}

Zooms in or out by moving the viewpoint along the line of sight. Rotate 
wheel forward or drag mouse forward with CTRL and middle mouse button 
pressed to zoom in. Rotate or drag backwards to zoom out.

\end{description}

\begin{sideblock}
On systems that have a one or two button mouse, the mouse bindings are
adjusted by default so that the {\tt ALT} modifier key emulates the
middle mouse button. Mouse bindings are discussed in detail in
Section \ref{MouseBindingsSec}.
\end{sideblock}

\label{axisAlignedViewpointsSec}
Predetermined viewpoints can also be selected using the {\it align axis}
button located on the viewer control bar.  Clicking on this
button produces an icon menu showing six different axis-aligned views.
Each view is indicated by the two axes perpendicular to the line
of sight, with the X, Y, and Z axes illustrated
by red, green, and blue lines respectively:

%\begin{description}

\begin{tabular}{l l l}
\iflatexml
\includegraphics[]{images/alignFront}
\else
\includegraphics[width=.33in]{images/alignFront}
\fi
& Front: & Z axis up, X axis to the right.\\
\iflatexml
\includegraphics[]{images/alignBack} 
\else
\includegraphics[width=.33in]{images/alignBack} 
\fi
& Back: & Z axis up, X axis to the left.\\
\iflatexml
\includegraphics[]{images/alignTop} 
\else
\includegraphics[width=.33in]{images/alignTop} 
\fi
& Top: & Y axis up, X axis to the right.\\
\iflatexml
\includegraphics[]{images/alignBottom} 
\else
\includegraphics[width=.33in]{images/alignBottom} 
\fi
& Bottom: & Y axis down, X axis to the right.\\
\iflatexml
\includegraphics[]{images/alignLeft} 
\else
\includegraphics[width=.33in]{images/alignLeft} 
\fi
& Left: & Z axis up, y axis to the right.\\
\iflatexml
\includegraphics[]{images/alignRight} 
\else
\includegraphics[width=.33in]{images/alignRight} 
\fi
& Right: & Z axis up, y axis to the left.
\end{tabular}
%\end{description}

The align axis button itself displays the most recently selected
axis-aligned view. Hitting the `{\tt v}' key from within the viewer
(Section \ref{keyShortcutsSec}) will realign the viewpoint to this
view.

\subsection{Adding additional viewers}

Additional viewers can be created by selecting {\sf View > New viewer}
from the main menu. Each viewer provides independent viewing and
selection control for the current model.

\begin{sideblock}
We are considering adding an option whereby the main viewer can
be split into four independent viewing panels, providing
orthogonal projections of the front, side, and top, along
with a general perspective projection. This arrangement is common
in CAD and geometric modeling applications.
\end{sideblock}

\subsection{Orthographic vs. perspective projection}
\label{ProjectionSec}

The user can toggle between orthographic and perspective projection by
selecting {\sf View > Orthographic view} or {\sf View > Perspective
view} from the main menu. Toggling can also be achieved using the
`{\tt o}' key shortcut (Section \ref{keyShortcutsSec}) within the
viewer.

\subsection{Viewer grid}
\label{ViewerGrid}

Hitting the `{\tt g}' key within the viewer enables or disables a grid
(Figure \ref{viewerGridFig}). Grid cells are square and appear in two
resolutions, with {\it major cells} subdivided into a number of {\it
minor cells}. Major cells are typically rendered more brightly than
minor cells. By default, the grid computes the cell sizes
automatically based on the current viewer zoom-level. However, it is
possible to set an explicit grid resolution (see
\ref{GridUnits}).

The grid is located in the plane perpendicular to the line of sight of
the most recently selected axis-aligned view. To change the grid
plane, select a new axis aligned viewpoint (Section
\ref{axisAlignedViewpointsSec}).

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/viewerGrid}
\else
\includegraphics[width=0.66\textwidth]{images/viewerGrid}
\fi
\end{center}
\caption{Viewer showing the grid.}%
\label{viewerGridFig}
\end{figure}

\subsubsection{Grid units}
\label{GridUnits}

When the grid is enabled, a box labeled {\sf Grid:} appears in the
toolbar on top of the main ArtiSynth frame which gives the current
resolution of the grid, displayed as {\tt S/N}, where {\tt S} is the
size of each major grid cell and {\tt N} is the number of subdivisions
per cell. If there are no subdivisions, then the {\tt /N} is omitted.
For example, in Figure \ref{viewerGridFig}, this appears as {\tt Grid:
1/10}, which means that the major grid cells have a size of 1.0 and
are each divided into 10 subdivisions. The numeric value of the ratio
{\tt S/N} gives the minor cell size.

By default, the grid automatically resizes itself to the current
viewer zoom level, choosing well-rounded numbers for the grid cell
size. Auto-sizing can be enabled or disabled by right-clicking on the
{\tt Grid:} label and choosing {\sf Turn auto-sizing on} or {\sf Turn
auto-sizing off}, as appropriate. The user can also specify an
explicit value for the grid resolution by entering the desired {\tt
S/N} value (or just an {\tt S} value) into the {\tt Grid:} box.
Specifying an explicit value will disable auto-sizing, unless {\tt S}
is specified as 0 or the special value {\tt *} is entered, both of
which will re-enable auto-sizing.

\subsubsection{Axis labeling}
\label{AxisLabels}

Hitting the `{\tt l}' key within the viewer enables or disables
labeling of the major divisions along the horizontal and vertical axis
(Figure \ref{gridLabels:fig}). The division lines along which these
labels appear are automatically adjusted so as to ensure proper label
visibility, and do not necessarily correspond to the x, y, or z axes.

\begin{figure}[h]
\begin{center}
\iflatexml
\includegraphics[]{images/gridLabels}
\else
\includegraphics[width=0.50\textwidth]{images/gridLabels}
\fi
\end{center}
\caption{Viewer grid with axis labels visible.}%
\label{gridLabels:fig}
\end{figure}

It is possible to control various properties associated with
axis labeling, such as which axes are labeled, and the label size and
color. See the next section on {\sf Grid properties}.

\subsubsection{Grid properties}
\label{GridProperties}

The grid has a number of properties that can be set by right-clicking
in the viewer and choosing {\sf Set viewer grid properties} (or by
right-clicking on the {\tt Grid:} label and choosing {\sf Set
properties}). This will bring up a property dialog, such as that shown
in Figure \ref{GridPropDialog:fig}.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/gridPropDialog}
\else
\includegraphics[width=0.4\textwidth]{images/gridPropDialog}
\fi
\end{center}
\caption{Dialog to control the grid properties.}%
\label{GridPropDialog:fig}
\end{figure}

Properties that can be set include:

\begin{description}

\item[resolution]\mbox{}

Grid resolution, as described above.

\item[autoSized]\mbox{}

If {\tt true}, causes the grid resolution to be recomputed as the user
adjusts the view position, orientation, and zoom.

\item[minCellPixels]\mbox{}

Minimum number of pixels that should appear in a minor cell division
when autosizing.

\item[majorColor]\mbox{}

Color to use for the major axis lines.

\item[minorColor]\mbox{}

Color to use for the minor axis lines.

\item[xAxisColor]\mbox{}

Color to use for the grid line that corresponds to the world y axis,
or the horizontal axis if {\sf lockAxesToWorld} is false.

\item[yAxisColor]\mbox{}

Color to use for the grid line that corresponds to the world y axis,
or the vertical axis if {\sf lockAxesToWorld} is false.

\item[zAxisColor]\mbox{}

Color to use for the grid line that corresponds to the world z
axis.

\item[lineWidth]\mbox{}

Width of the grid lines, in pixels.

\item[position]\mbox{}

Translation position of the grid, in world coordinates.

\item[orientation]\mbox{}

Orientation of the grid, in world coordinates.

\item[lockAxesToWorld]\mbox{}

If {\tt true}, forces the grid to stay aligned with the orientation
and position of the world axes. In particular, the horizontal and
vertical axes will always be parallel to one of the x, y, or z world
axes, the grid center will be a multiple of major cell sizes from the
origin, and axis labels will be set relative to the world origin.

\item[useWorldOrigin]\mbox{}

If {\tt true}, causes the principal horizontal and vertical axes to be
aligned with the world origin. Otherwise, the axes will be aligned
with the grid center. This property can only be {\tt true} if {\sf
lockAxesToWorld} is also {\tt true}.

\item[xAxisLabeling]\mbox{}

Enables labeling of the x axis.

\item[yAxisLabeling]\mbox{}

Enables labeling of the y axis.

\item[labelSize]\mbox{}

'em' size of the label text, in pixels.

\item[labelColor]\mbox{}

If set, specifies the color used to draw the label text. Otherwise,
the major axis color is used.

\end{description}

\subsection{Clipping planes}
\label{ClippingPlanesSec}

The user can add clipping planes to the viewer. These are useful for
restricting what is rendered and allowing a better view of interior
structures, as shown in (Figure \ref{clipPlaneFig}).

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/clipPlane}
\else
\includegraphics[width=0.66\textwidth]{images/clipPlane}
\fi
\end{center}
\caption{Clipping plane showing interior of tongue model (left), disabled (center), and in slice mode (right).}%
\label{clipPlaneFig}
\end{figure}

\subsubsection{Adding and removing}

To add a clipping plane, left click on the {\sf add clip plane}
button \includegraphics[width=.25in]{images/addClipPlane} located on the
viewer toolbar. This will create a clipping plane located in the plane
perpendicular to the current line of sight.

It will also add to the viewer toolbar a {\sf clip plane} icon
\includegraphics[width=.25in]{images/clipPlaneIcon} for controlling the
clipping plane. Right-clicking on this icon will bring up an option
menu.

To delete a clipping plane, right-click on its icon and
select {\sf Delete}.

\subsubsection{Moving}

A clip plane is associated with a coordinate system and can be moved
and/or rotated by dragging on the trans-rotate transformer located at
its coordinate system origin. The clip region is the half space lying
in the direction of the +z axis.

The transformer itself can be made invisible/visible by right-clicking
on the clip plane icon and selecting {\sf Hide transformer} or {\sf Show
transformer}.

\subsubsection{Offsets}

The clipping region is the half space lying in the direction of the +z
axis of the plane's local coordinate system. By default, clipping is
actually offset by a small distance along the +z axis, so that small
objects (such as points) lying in the x-y plane remain
visible. The amount of this offset is controlled by the plane's
{\sf offset} property, which is set to a nominal default value. To control
this property directly, right-click on the clip plane icon and select
{\sf Set properties}. This will bring up a panel which allows the offset
to be adjusted.

\subsubsection{Enabling/disabling}

Left clicking on the clip plane icon will enable/disable
clipping. Disabling clipping allows the plane to be used as a regular
movable grid. When clipping is disabled, the icon
will change to the form
\includegraphics[width=.25in]{images/clipPlaneOffIcon}.

\subsubsection{Slicing mode}

Clipping planes can be placed in a {\it slicing mode}, whereby half-spaces
in both the positive and negative z directions are clipped. The result
is a small slice about the local x-y plane (Figure \ref{clipPlaneFig},
right). The width of this slice is controlled by the plane's {\sf offset}
property, as described above.

To enable or disable slicing, right-click on the clip plane icon
and select {\sf Enable slicing} or {\sf Disable slicing}.

\subsubsection{Other features}

\begin{description}

\item[Properties]\mbox{}

Various properties associated with the plane, such as its color, line
width, cell resolution, etc., can be set explicitly by the user. To do
this, right-click on the icon, select {\sf Set properties}, and edit
the resulting property panel.  Most properties are the same as those
described for the main viewer grid in \ref{GridProperties}.

\item[Grid visibility]\mbox{}

To make the grid invisible/visible, right-click on the icon
and select {\sf Hide grid} or {\sf Show grid}.

\item[Alignment with world axes]\mbox{}

The clip plane can be aligned so that it's
normal lies along the positive or negative direction of either the x,
y, or z world axes. Right-click on the icon and select the
appropriate option. Clipping is performed so that
the half-space lying in the direction of the normal is clipped.

\item[Alignment with current line of sight]\mbox{}

To align the clipping plane so that it is perpendicular to the
current line of sight, right-click on the icon and select {\sf Reset}.

\end{description}

\subsection{Indicating 3D positions with the mouse}
\label{indicatingPositionsSec}

It is possible to use a viewer in combination with a mouse to specify the
position of a 3D point in space. This is commonly employed in the
editing operations described in Section \ref{componentEditingSec}.

To specify a point, the user left-clicks the mouse in the viewer, at
the screen position located over the point's desired position. The 3D
position is then determined by intersecting the ray indicated by the
mouse clock with some appropriate surface or plane. Typically, a plane
perpendicular to the viewing direction and passing through the model's
center is used. Alternatively, some interactions provide a {\sf constrain
to plane} option, which causes the ray to be intersected with a viewer
clipping plane (Section \ref{ClippingPlanesSec}), providing more precise control
over the point's position. This requires that the viewer presently
contain at least one clipping plane. If more than one clipping plane
is present, the first one is used.

In other applications, the desired point may be known to lie on a 3D
surface, in which case the position is determined by intersecting the
ray with a 3D surface mesh.

\subsection{Alternate mouse bindings}
\label{MouseBindingsSec}

The ArtiSynth GUI was originally designed for a three-button mouse, in
which the left button is used for selection, the middle button
controls the viewpoint, and the right button is used to activate the
context menu. These are used in conjunction with the modifier keys
{\tt SHIFT} and {\tt CTRL} to effect different actions.

For systems that do not have a three-button mouse, ArtiSynth by
default detects the number of mouse buttons and adjusts the mouse
bindings so that the {\tt ALT} key emulates the middle button and the
{\tt META} key emulates the right button.

\begin{sideblock}
The {\tt META} key is usually associated with either the {\tt COMMAND}
key (Mac) or the {\tt WINDOWS} key.
\end{sideblock}

Mouse bindings can also be explicitly set by the user, by opening the
mouse preferences dialog {\sf Settings > Mouse Preferences} and then
choosing the desired binding. This dialog also displays the button and
modifier combinations associated with different actions. Alternate
bindings may also be requested from the command line using the {\tt
-mousePrefs <bindings>} option. Currently, there are three default
and two legacy bindings:

\begin{description}

\item[ThreeButton]\mbox{}

Default bindings for a three-button mouse.

\item[TwoButton]\mbox{}

Default bindings for a two-button mouse. The middle mouse button
is emulated with the {\tt ALT} key.

\item[OneButton]\mbox{}

Default bindings for a one-button mouse. The middle and right mouse
buttons is emulated with the {\tt ALT} and {\tt META} keys.

\item[Laptop]\mbox{}

Legacy bindings for a two-button mouse.

\item[Mac]\mbox{}

Legacy bindings for a Mac type one-button mouse.

\end{description}

Tables showing the button and modifier combinations that effect
different actions with each of these binding are given below, with
{\tt LMB}, {\tt MMB}, and {\tt RMB} denoting the left, right and
middle mouse buttons.  Actions marked with an asterisk (*) are drag
actions which can have their modifier keys invoked or removed during a
drag operation.

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
Action & {\sf ThreeButton} & {\sf TwoButton} & {\sf OneButton}\\
\hline
\hline
\multicolumn{4}{|l|}{Viewpoint control (Section \ref{ViewpointControlSec})}\\
\hline
Rotate view & 
{\tt MMB} & {\tt MMB}+{\tt ALT} & {\tt MMB}+{\tt ALT}\\
Translate view & 
{\tt MMB}+{\tt SHIFT} & {\tt MMB}+{\tt ALT}+{\tt SHIFT} & 
{\tt MMB}+{\tt ALT}+{\tt SHIFT}\\
Zoom view & 
{\tt MMB}+{\tt CTRL} & {\tt MMB}+{\tt ALT}+{\tt CTRL} & 
{\tt MMB}+{\tt ALT}+{\tt CTRL}\\
\hline
\multicolumn{4}{|l|}{Component selection (Section \ref{viewerSelectionSec})}\\
\hline
Single selection & 
{\tt LMB} & {\tt LMB} & {\tt LMB}\\
Multiple selection & 
{\tt LMB}+{\tt CTRL} & {\tt LMB}+{\tt CTRL} & {\tt LMB}+{\tt CTRL}\\
Elliptic selection & 
{\tt LMB} & {\tt LMB} & {\tt LMB}\\
Elliptic deselection$^*$ & 
{\tt LMB}+{\tt SHIFT} & {\tt LMB}+{\tt SHIFT} & {\tt LMB}+{\tt SHIFT}\\
Resize paint ellipse & 
{\tt LMB}+{\tt SHIFT}+{\tt CTRL} & {\tt LMB}+{\tt SHIFT}+{\tt CTRL} & 
{\tt LMB}+{\tt SHIFT}+{\tt CTRL}\\
Context menu & 
{\tt RMB} & {\tt RMB} & {\tt LMB}+{\tt META}\\
\hline
\multicolumn{4}{|l|}{Transformer control (Section \ref{TransformerToolsSec})}\\
\hline
Move & 
{\tt LMB} & {\tt LMB} & {\tt LMB}\\
Constrained move$^*$ & 
{\tt LMB}+{\tt SHIFT} & {\tt LMB}+{\tt SHIFT} & {\tt LMB}+{\tt SHIFT}\\
Reposition$^*$ & 
{\tt LMB}+{\tt CTRL} & {\tt LMB}+{\tt CTRL} & {\tt LMB}+{\tt CTRL}\\
\hline
\end{tabular}
\end{center}

while the legacy bindings are:

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
Action & {\sf Laptop} & {\sf Mac}\\
\hline
\hline
\multicolumn{3}{|l|}{Viewpoint control (Section \ref{ViewpointControlSec})}\\
\hline
Rotate view & 
{\tt LMB} & {\tt LMB}+{\tt ALT}\\
Translate view & 
{\tt LMB}+{\tt SHIFT} & {\tt LMB}+{\tt ALT}+{\tt SHIFT} \\
Zoom view & 
{\tt LMB}+{\tt ALT} & {\tt LMB}+{\tt ALT}+{\tt META} \\
\hline
\multicolumn{3}{|l|}{Component selection (Section \ref{viewerSelectionSec})}\\
\hline
Single selection & 
{\tt LMB}+{\tt CTRL} & {\tt LMB} \\
Multiple selection & 
{\tt LMB}+{\tt SHIFT}+{\tt CTRL} & {\tt LMB}+{\tt META} \\
Elliptic selection & 
{\tt LMB}+{\tt CTRL} & {\tt LMB} \\
Elliptic deselection$^*$ & 
{\tt LMB}+{\tt SHIFT}+{\tt CTRL} & {\tt LMB}+{\tt SHIFT} \\
Resize paint ellipse & 
{\tt LMB}+{\tt SHIFT}+{\tt CTRL} & {\tt LMB}+{\tt SHIFT}+{\tt CTRL}\\
Context menu & 
{\tt RMB} & {\tt LMB}+{\tt CTRL} \\
\hline
\multicolumn{3}{|l|}{Transformer control (Section \ref{TransformerToolsSec})}\\
\hline
Move & 
{\tt LMB} & {\tt LMB} \\
Constrained move$^*$ & 
{\tt LMB}+{\tt SHIFT} & {\tt LMB}+{\tt SHIFT} \\
Reposition$^*$ & 
{\tt LMB}+{\tt ALT} & {\tt LMB}+{\tt ALT} \\
\hline
\end{tabular}
\end{center}

\subsection{Keyboard shortcuts}
\label{keyShortcutsSec}

When the viewer has the keyboard focus, the following key shortcuts
are available:

\begin{center}
\begin{tabular}{|l|l|}
\hline
Key & Operation \\
\hline
{\tt q} & quit ArtiSynth \\
{\tt t} & toggle time line visibility \\
{\tt z} & undo last command \\
\hline
\multicolumn{2}{|l|}{Play controls (Section \ref{SimulatingSec}):}\\
\hline
{\tt p} or {\tt SPC} & play/pause\\
{\tt s} & single step \\
{\tt r} & reset \\
\hline
\multicolumn{2}{|l|}{Viewer controls:}\\
\hline
{\tt v} & reset view (Section \ref{ViewpointControlSec})\\
{\tt o} & toggle orthographic/perspective view 
(Section \ref{ProjectionSec})  \\
{\tt a} & toggle visibility of axes showing world coordinates\\
{\tt g} & toggle viewer grid (Section \ref{ViewerGrid})\\
{\tt l} & toggle viewer grid labels\\
\hline
\multicolumn{2}{|l|}{%
Selection and transformer (Sections \ref{viewerSelectionSec} 
and \ref{TransformerToolsSec}):}\\
\hline
{\tt ESC} & select parent of last selection\\
{\tt c} & clear selection\\
{\tt d} & reset elliptic cursor size to default\\
{\tt w} & set current transformer frame to world coordinates\\
{\tt b} & set current transformer frame to body/local coordinates\\
\hline
\end{tabular}
\end{center}

\section{Component Navigation and Selection}

An ArtiSynth model is composed of a hierarchical arrangement of
model components (each of which implements the interface 
\javaclass[artisynth.core.modelbase]{ModelComponent}), 
some of which may themselves
be models. The graphical interface allows users to navigate this
hierarchy and select individual components. Selected components
can then be edited, or have specific properties modified or attached
to probes or control panels.

\subsection{The component hierarchy}
\label{hierarchySec}

An example component hierarchy is shown in Figure
\ref{hierarchyFig}. At the top is a {\it root model} (class
\javaclass[artisynth.core.workspace]{RootModel}), 
in this case named {\tt Rigid Body Spring}.  The
root model in turn contains a list of models, one of which is a
mechanical model named {\tt msmod}, which here contains particles and
rigid bodies.

It is important to node that in the component hierarchy, any collection
of components is itself a component (usually an instance of
\javaclass[artisynth.core.modelbase]{ComponentList}). 
This provides automatic ``grouping'' of
components of like type, but does introduce additional levels into the
hierarchy. Hence the particle {\tt red} is a child not of {\tt msmod},
but rather the component list {\tt particles}.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/hierarchy}
\else
\includegraphics[width=0.66\textwidth]{images/hierarchy}
\fi
\end{center}
\caption{A sample component hierarchy.}%
\label{hierarchyFig}
\end{figure}

\subsubsection{Component names and numbers}

Model components may be assigned a string name; at the time of
this writing names may not begin with a digit, have zero length, contain
the characters `{\tt .}' or `{\tt /}', or equal the reserved word {\tt this}.
Components which do not have an assigned name are
called {\it nameless}.

All components have a {\it number}, even if they do not have a name. The
number is assigned automatically when the component is added to the
parent, and is guaranteed to be persistent until the component is
removed from the parent.

\subsubsection{Component path names}
\label{pathNamesSec}

The names and/or numbers of a component's ancestors can be used to
form a {\it component path name}. This path has a construction completely
analogous to Unix file path names, with the `{\tt /}' character acting as
a separator. Absolute paths start with `{\tt /}' and begin with the root
model. Relative paths omit the leading `{\tt /}' and can begin lower down
in the hierarchy.  The absolute path name of the {\tt red} particle in
Figure \ref{hierarchyFig} would be

\begin{verbatim}
/Rigid Body Spring/models/msmod/particles/red
\end{verbatim}

For nameless components in the path, their
numbers can be used instead:

\begin{verbatim}
 /Rigid Body Spring/models/msmod/rigidBodies/1
\end{verbatim}

Numbers can be used even for components that have names.
Hence a path name consisting only of numbers, as in

\begin{verbatim}
 /0/0/0/3/1
\end{verbatim}

is legal, although it most likely to appear only in machine-generated
output.

\subsection{Navigation panel selection}
\label{navPanelSec}

A navigation panel in the main ArtiSynth frame allows direct
navigation of the component hierarchy. The panel can be
open or closed by clicking on the main toolbar icon 
\iflatexml
\includegraphics[]{images/navpanelIcon}.
\else
\includegraphics[width=.25in]{images/navpanelIcon}.
\fi

Figure \ref{navpanelFig} shows an navigation panel containing a superset
of the hierarchy diagrammed in Figure \ref{hierarchyFig}.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/navpanel}
\else
\includegraphics[width=0.30\textwidth]{images/navpanel}
\fi
\end{center}
\caption{An typical navigation panel display.}%
\label{navpanelFig}
\end{figure}

Left clicking on any component in the navigation panel selects that
component. Clicking while pressing the {\tt CTRL} key (or the {\tt
CMD} key on some platforms, such as Mac) allows selection of multiple
components. Clicking while pressing the {\tt SHIFT} key allows
selection of a range of components.

\subsubsection{Large numbers of nameless components}

In some cases, such as finite element models, the number of child
components can be very large (on the order of thousands). In order to
keep the navigation panel size manageable, the number of nameless
children displayed is limited to a set number (currently 100).  If the
number of nameless children exceeds this number, the display will be
augmented with an expand icon {\tt >>>}. Clicking on this will expand the
display to include all nameless components, and the expand icon will
be replaced by a contract icon {\tt <<<}. Clicking on the contract icon
will cause the extra nameless components to be hidden again.
This is illustrated in Figure \ref{navpanelExpandContractFig}.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/navpanelContractExpand}
\else
\includegraphics[width=0.66\textwidth]{images/navpanelContractExpand}
\fi
\end{center}
\caption{Expansion of nameless components in the navigation panel.}%
\label{navpanelExpandContractFig}
\end{figure}

\subsection{Viewer selection}
\label{viewerSelectionSec}

Components that are rendered in the viewer can generally be selected
by variety of methods (the exception is for a few renderable
components that do not support selection). These methods include {\it click},
{\it box}, and {\it elliptic} selection. The top two icons in the
selection toolbar at the left of the ArtiSynth frame control the
current selection method. In addition, hitting the `{\tt c}' key
from within the viewer
(Section \ref{keyShortcutsSec}) clears the current selection.

\subsubsection{Click and box selection}

Click and box selection are enabled by the arrow icon at the top of
the selection toolbar:

\vspace{\parskip}
\iflatexml
\includegraphics[]{images/selectTool}
\else
\includegraphics[width=.33in]{images/selectTool}
\fi

Click selection involves left clicking on a component, causing it to
be selected. Selection of multiple components is enabled by left
clicking with a modifier key, which is usually {\tt CTRL}
but may be different for some legacy mouse bindings 
(Section \ref{MouseBindingsSec}).

\begin{sideblock}
Click selection selects only those components which are actually
visible to the viewer; components which are hidden cannot be selected
this way.
\end{sideblock}

Box selection is effected by left-clicking and dragging in the viewer,
causing the selection of all components rendered within the resulting
drag box. Because this often results in the selection of more
components than desired, it may be useful to employ a selection filter
(Section \ref{selectionFiltersSec}). Any components within the drag
box which are already selected will be deselected.

\begin{sideblock}
Box selection acts on {\it all} (filtered) components within the view
frustum defined by the drag box, including those which are hidden
from view.
\end{sideblock}

\subsubsection{Elliptic selection}

Elliptic selection is enabled by the elliptic icon near the top of
the selection toolbar:

\vspace{\parskip}
\iflatexml
\includegraphics[]{images/ellipticSelectTool}
\else
\includegraphics[width=.33in]{images/ellipticSelectTool}
\fi

This causes an additional elliptic cursor (which defaults to a circle)
to be drawn around the mouse cursor. Selection is effected by
dragging, and causes all visible objects within the ellipse to be
selected. The selection process is cumulative, with subsequent drags
selecting additional components. As with all selection operations, a
filter can be set to restrict the components that are selected
(Section \ref{selectionFiltersSec}). Generally, the drag select
operation requires no modifier keys, although it may with some legacy
mouse bindings (Section \ref{MouseBindingsSec}).

It is also possible to {\it deselect} components in the same way, by
using the {\tt SHIFT} modifier key to cause drag operations to
cumulatively deselect components.
	
\begin{sideblock}
Elliptic selection selects only those components which are actually
visible to the viewer; components which are hidden cannot be selected
this way.
\end{sideblock}

The elliptic cursor used for selection can be resized, either
interactively, or by setting the {\tt ellipticCursorSize} property of
the viewer. To interactively change the cursor, initiate a drag
operation with the {\tt CTRL} and {\tt SHIFT} modifiers.
To set the {\tt ellipticCursorSize}, invoke the context menu
(usually right-click) in the viewer when nothing is selected, and
choose {\sf Set viewer properties}. Finally, the `{\tt d}' key
shortcut within the viewer will cause the cursor to be reset to its
default size.

\subsubsection{Selection filtering}
\label{selectionFiltersSec}

It is possible to limit viewer selection to components of a specific
type. This can be done using the selection filter widget at the bottom
left of the main ArtiSynth frame Figure
\ref{selectionFilterWidgetFig}.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/selectionFilterWidget}
\else
\includegraphics[width=0.40\textwidth]{images/selectionFilterWidget}
\fi
\end{center}
\caption{The selection filter widget.}%
\label{selectionFilterWidgetFig}
\end{figure}

To enable filtering, type into the widget text box the class name of
the component type you wish to restrict filtering to. It is generally
only necessary to enter the leaf name of the class (e.g., {\tt Particle}
or {\tt AxialSpring}), and the system will then find the full
class name by searching the ArtiSynth class path.

Once filtering is enabled, only components which are instances
(including subclasses) of the specified type will be selectable.

Previously selected filters can be recalled using a history
list accessible using the leftmost arrow button on the
selection widget.

To remove selection filtering, enter the special filter {\tt *}, either by
typing this in the text box, or using the history list.

\subsection{Selection display}
\label{selectionDisplaySec}

The selection display Figure \ref{selectionDisplayWidgetFig} at the bottom of the
main ArtiSynth frame shows the full path name of the last component
added to the selection list. This is useful for identifying components
in detail.

If no components are selected, then the selection display is blank.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/selectionDisplay}
\else
\includegraphics[width=0.50\textwidth]{images/selectionDisplay}
\fi
\end{center}
\caption{The selection display widget.}%
\label{selectionDisplayWidgetFig}
\end{figure}

The selection display is useful for disambiguating situations where it
is not clear what component we have actually selected in the viewer.
For example, FEM models keep their surface mesh contained within a
descendant component. Selecting the surface mesh will cause this
container component to be selected and highlighted, making it {\it
appear} as though the FEM model itself is selected rather than the
container. Checking the selection display makes it clear
what component has actually been selected. If desired,
one can easily navigate to one of the ancestor components
using parent selection, as described in the next section.

\subsection{Selecting parent and ancestor components}
\label{selectingAncestorsSec}

Sometimes, when you select a component, you actually want to select
one of it's ancestor components. 

There are several ways to do this:

\begin{enumerate}

\item Hit the escape ({\sf ESC}) key within the viewer window. This
will select the parent of the currently selected component. Hitting
escape repeatedly is a fast way to proceed up the component hierarchy.

\item Click on the ``up'' arrow located at the left of the selection
display (Figure \ref{selectionDisplayWidgetFig}). This will also
select the parent of the currently selected component.

\end{enumerate}

Parent selection is particularly useful in the commonly occurring
situation where a composite component is not rendered and therefore
not selectable in the viewer. For instance, suppose we wish to select
a FEM model. One can select any renderable descendant of the model,
such as a node, element, or its surface mesh (if displayed), and then
use repeated parent selection until the model itself is selected.

\subsection{Highlighting selected components}

Selected components are rendered in the viewer using a special
selection color (yellow at the time of this writing). It is important
to note that descendants of a selected component are {\bf not} presently
rendered in any special way. For instance, if an FEM is selected, it's
nodes and elements will be rendered normally. 

While this has the potential to be confusing, we have not yet found
this to be problematic, as the navigation panel and selection display
provide alternative indicators as to what is currently selected.

\section{Model Manipulation}
\label{ModelManipulation}

Various tools located within the selection toolbar at the left of the
main ArtiSynth frame allow models to be manipulated in various ways.
These include modifying component locations, orientations, and
geometry using the transformer tools (Section
\ref{TransformerToolsSec}), exerting point forces on selected
components using the pull controller (Section
\ref{PullControllerSec}), and adding marker points to certain
components types (Section \ref{MarkerTool}).

The behavior of these tools is somewhat context dependent.  For
example, the transformer tools will only transform those {\it
transformable} components which implement the
\javaclass[artisynth.core.modelbase]{TransformableGeometry}
interface. The behavior may also vary depending on whether or not
simulation is in progress.

\subsection{Dragger fixtures}
\label{draggerFixturesSec}

The transformation tools employ the dragger fixtures shown
in Figure \ref{transformToolsFig}, which allow 3D geometrical
transformations to be performed within the viewer.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/transformTools}
\else
\includegraphics[width=0.80\textwidth]{images/transformTools}
\fi
\end{center}
\caption{Dragger fixtures: translator, rotator, and transrotator.}%
\label{transformToolsFig}
\end{figure}

\begin{description}

\item[Translator]\mbox{}

Effects a translation. The x, y, and z axes are
indicated by red, green, and blue lines. Dragging any line causes
a one-dimensional motion along the associated axis. Dragging one
of the boxes causes a two-dimensional motion in the associated plane.

\item[Rotator]\mbox{}

Effects a rotation. Rotation about the
x, y, and z axes is indicated by red, green, and blue circles.
Selecting and dragging along one of these circles produces
a rotation about the corresponding axis.

\item[TransRotator]\mbox{}

Combines the translator and rotator into a single tool. One difference
is that the axes of the transRotator move with any rotation,
and so operations are done with respect to the transRotator coordinate frame
at the beginning of the drag.

\end{description}

\begin{sideblock}
Under the default mouse bindings, the basic drag operations involving
these fixtures are invoked using the left mouse button with no
modifier keys. Additional modifier keys allow constrained transformation
or repositioning of the fixture, as described below.
\end{sideblock}

\subsection{Transformer tools}
\label{TransformerToolsSec}

A number of transformer tools use the dragger fixtures described
above to translate, rotate, and scale components. Once a tool is
activated, then selecting one or more transformable components will
cause the corresponding dragger fixture to appear in the viewer at the
components' location. If a single component is selected and 
that component is 
associated with a coordinate frame (by implementing the
\javaclass[artisynth.core.modelbase]{HasCoordinateFrame} interface), 
then the dragger's initial position
and orientation are aligned with this coordinate frame.
Otherwise, the dragger is initially placed at the center of the
components' bounding box and its orientation is aligned to world
coordinates.

To request that a dragger's initial orientation is {\it always}
aligned with world coordinates, choose {\sf Init draggers in world
coordinates} in the ArtiSynth {\sf Settings} menu. To restore the
default behavior, choose {\sf Init draggers in local coordinates}.

%\iflatexml
%% HACK: we put a '.' before the image to get LaTeXML to set it on the
%% same line as the following text.
%.\includegraphics[]{images/selectTool}
%\else
%\includegraphics[width=.33in]{images/selectTool}
%\fi
%{\sf Selection:}\\
%Click and box selection mode. Turns off manipulation.
%
%\vspace{\parskip}
%\iflatexml
%.\includegraphics[]{images/ellipticSelectTool}
%\else
%\includegraphics[width=.33in]{images/ellipticSelectTool}
%\fi
%{\sf Elliptic Selection:}\\
%Elliptic selection mode. Turns off manipulation.

\vspace{\parskip}
\iflatexml
% HACK: we put a '\phantom{.}' before the image to get LaTeXML to set
% it on the same line as the following text.
\phantom{.}\includegraphics[]{images/translateTool}
\else
\includegraphics[width=.33in]{images/translateTool}
\fi
{\sf Translation:}\\
Translates selected components using the translator dragger.

\vspace{\parskip}
\iflatexml
\phantom{.}\includegraphics[]{images/rotateTool}
\else
\includegraphics[width=.33in]{images/rotateTool}
\fi
{\sf Rotation:}\\
Rotates selected components using the rotator dragger.

\vspace{\parskip}
\iflatexml
\phantom{.}\includegraphics[]{images/transRotateTool}
\else
\includegraphics[width=.33in]{images/transRotateTool}
\fi
{\sf TransRotation:}\\
Translates and rotates selected components
using the transRotate dragger. The transformation reference frame
moves with the tool.

\vspace{\parskip}
\iflatexml
\phantom{.}\includegraphics[]{images/constrainedTool}
\else
\includegraphics[width=.33in]{images/constrainedTool}
\fi 
{\sf Constrained translation:}\\
Translates selected components using the translate dragger while ensuring that
they are constrained to remain on a surface mesh. Only components with
an associated surface mesh (such as FrameMarkers attached to a
RigidBody) can be transformed this way.

\vspace{\parskip}
\iflatexml
\phantom{.}\includegraphics[]{images/scaleTool}
\else
\includegraphics[width=.33in]{images/scaleTool}
\fi
{\sf Scaling:}\\
Scales selected components using the transrotator
fixture. Instead of translating, translational drag operations
scale the component along the x, y, or z axes, or in the
x-y, y-z, or z-x planes. Rotational operations, if
used in conjunction with an appropriate modifier key,
can be used to change the orientation of the scaling axes,
as described in \ref{ChangingTransformerPose}.

%\end{description}

\subsubsection{Constrained transformation}

Under the default mouse bindings, pressing the {\tt SHIFT} modifier
key causes drag operations to be constrained to discrete step sizes.
Rotation operations are constrained to
intervals of five degrees, while translation operations are
constrained to either the grid spacing (if a grid is selected, see
\ref{ViewerGrid}), or to a suitable well-rounded number depending on
the viewer's zoom level.

\subsubsection{Transformer repositioning}
\label{ChangingTransformerPose}

Under the default mouse bindings, pressing the {\tt CTRL} modifier key
causes the dragger fixture to move independently of the selected
objects. This allows its position and orientation
relative to the selected objects to be changed. This is particularly
useful for changing the orientation of the scaling directions in the
scaling tool.

\subsubsection{Changing the transformer base frame}

By default, a transformer is assigned a local coordinate frame for the
object(s) that it is positioning, based on either the object's own
body frame (if it has one), or the objects' bounding box. This frame
will then move with the transformer, and may also move relative to the
object(s) if the transformer is repositioned (Section
\ref{ChangingTransformerPose}).

Sometimes, it may be desirable to explicitly reset the transformer's
frame. This may be done using the following shortcut keys in the
viewer:

\begin{description}

\item[{\tt w}]\mbox{}

Set the transformer frame to the world coordinate system, allowing
subsequent transformations to be performed in world coordinates;

\item[{\tt b}]\mbox{}

Reset the transformer frame to the original local frame for the
object(s), based on either the object's body frame or the objects'
bounding box.

\end{description}

\subsection{Pull manipulation}
\label{PullControllerSec}

\vspace{\parskip}
\iflatexml
\phantom{.}\includegraphics[]{images/pullTool}
\else
\includegraphics[width=.33in]{images/pullTool}
\fi
{\sf Pull tool:}\\
Pulls on certain components using a spring-like force
when simulation is running.

\begin{figure}[h]
\begin{center}
\iflatexml
\includegraphics[]{images/pullManipulation}
\else
\includegraphics[width=0.6\textwidth]{images/pullManipulation}
\fi
\end{center}
\caption{Applying pull manipulation (blue arrow) to a rigid body 
attached to a multi-point spring.}%
\label{PullManipulationFig}
\end{figure}

Selecting the {\it pull} tool allows a user to interactively apply a
spring-like force to certain component types by clicking on it and
then dragging (Figure \ref{PullManipulationFig}). Double clicking on
the component adds a {\it pull point} that persists between mouse
clicks; to remove the pull point, double click on the viewer
background.

The pull tool works on points, rigid bodies, FEM models, or any other
component that implements the
\javaclass[artisynth.core.mechmodels]{PointAttachable} interface and
has a surface mesh. Pull manipulation is only effective when
simulation is running.  It works by adding a special {\tt
PullController} to the current root model's set of controllers. When
attached to the root model, the controller attempts to estimate an
appropriate spring stiffness based on the overall mass and dimensions
of the first underlying {\tt MechModel}.

If necessary, the pull tool's stiffness setting can also be adjusted
manually by selecting {\sf PullController > properties} in the {\sf
Settings} menu.  Render properties for the pull controller can be set
from this menu also.

\subsection{Marker tool}
\label{MarkerTool}

\vspace{\parskip}
\iflatexml
\phantom{.}\includegraphics[]{images/markerTool}
\else
\includegraphics[width=.33in]{images/markerTool}
\fi
{\sf Marker tool:}\\
Adds point markers to certain components.

Selecting the {\it marker} tool allows a user to interactively add
point markers to various components in the model.

Markers can be added by double-clicking on rigid bodies, FEM models,
and other components that implement the
\javaclass[artisynth.core.mechmodels]{IsMarkable} interface.

\begin{sideblock}
Markers are typically added to a component's surface mesh, and in such
cases it is necessary that this surface mesh be visible. For FEM
models in particular, the {\sf surfaceRendering} property should be
set to something other than {\tt None}. To ensure this is the case,
select the FEM model, right-click and choose {\sf Edit properties
...}, and examine the setting for {\sf surfaceRendering}. An FEM model
can sometimes {\it appear} to have a visible surface mesh, even if it
doesn't, if its {\sf elementWidgetSize} property is close to 1.
\end{sideblock}

The markers themselves are added to the current root model at a
location that depends on the component being marked:

\begin{itemize}
\item {\bf Rigid bodies:} marker is added to the {\tt frameMarker}
list for the body's parent {\tt MechModel};

\item {\bf FEM models:} marker is added to the FEM model's {\tt marker} list;

\item {\bf IsMarkable components:} marker is added to the root model's
{\tt marker} list (which is created on demand if needed).

\end{itemize}

In order for added markers to be visible, the component list into
which they are placed needs to be visible, with its point rendering
properties set to appropriate values. That usually means that {\sf
pointStyle} is set to {\tt SPHERE} or {\tt CUBE}, with {\tt
pointRadius} set to a value commensurate with the model's dimensions,
{\it or} {\sf pointStyle} is set to {\tt POINT}, with {\sf pointSize}
set to a sufficiently large value in pixels.  If not set within the
list itself, the point rendering properties will be inherited from
ancestor components. For example, if a {\tt MechModel}'s point render
properties are set for good visibility, then all points within
subcomponents will be visible unless these setting have been
overridden at a lower point in the hierarchy.

\begin{sideblock}
If markers are not appearing when using the marker tool, use the
navigation panel to open the component list to which the markers are
added (as described above). Verify that markers are actually being
appended to the end of the list. If they are not, ensure that the
component's surface mesh is visible. If they are, select the list
itself, right-click, and choose {\sf Edit render props ...}. Check
that {\sf visible} is {\tt true}, and that {\sf pointStyle} and {\sf
pointRadius} (or {\sf pointSize}) are set appropriately.
\end{sideblock}

Once created, markers can be removed by selecting them and choosing
{\sf Delete} from the context menu.

\section{Editing Properties}

Most ArtiSynth model components have properties which can be 
changed onscreen through the graphical interface. Properties
include a diverse set of attributes ranging from stiffness and
damping for AxialSprings, position and velocity for particles and
rigid bodies, or whether or not a component is dynamic.

The underlying software architecture of the property interface is 
described in the Properties chapter of the\\
\artisynthManual{maspack}{Maspack Reference Manual}.

\subsection{Property panels}
\label{propertyPanelsSec}

To edit properties for a set of components, select the components in
question, then right-click in either the viewer or the navigation
panel, and select {\sf Edit properties}. This will create a {\it property
panel} for all properties which are common to the selected components.
All typical property panel is shown in Figure \ref{propertyPanelFig}.

Property panels are initialized with the current values of the selected
components, providing a view of the current property state. A blank
property value will be displayed when more than one component is selected and 
the corresponding property value differs across components.

Some properties are {\it read only}. In this case, the corresponding
widget in the property panel will display the value but will be
disabled.

\begin{figure}[h]
\begin{center}
\iflatexml
\includegraphics[]{images/propertyPanel}
\else
\includegraphics[width=0.40\textwidth]{images/propertyPanel}
\fi
\end{center}
\caption{A typical property panel.}%
\label{propertyPanelFig}
\end{figure}

Property panels are non-modal and persistent. 
They can be deleted by
closing them or clicking the {\sf OK} button. Clicking the {\sf Cancel} button
will cause the properties to be reset to their values at the time to
panel was created.

Normally, a property panel will refresh its widget values whenever the
model view is rerendered. In particular, this will happen repeatedly
while simulation is running. To disable the automatic refresh, click
the {\sf live updating} button 
\iflatexml
\includegraphics{images/liveUpdateIcon}
\else
\includegraphics[width=.25in]{images/liveUpdateIcon}
\fi
at the lower
left of the panel.

\subsubsection{Inheritable properties}

Some properties are inheritable. The value of an inheritable property
can be {\it explicitly} set or it can be inherited.  If inherited, then it
inherits its value from ancestor components further up the hierarchy.
More specifically, if a property's value is inherited, then the value
is obtained from the nearest ancestor in which the same property
exists and is explicitly set.  If no such ancestor exists, then the
property is set to a default value.

The inherited/explicit status of an inheritable property is controlled
by an additional button placed at the left of the property widget
(Figure \ref{inheritedButtonFig}).  Clicking this button toggles the
inherited/explicit status.  If set to inherited, then the property's
value is determined from the hierarchy and the updated value is placed
in the widget.  Setting the value in the widget itself will cause the
inheritable status to be set to explicit, and the value of inherited
instances of the same property in descendant nodes will be updated
accordingly.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/inheritedButton}
\else
\includegraphics[width=0.80\textwidth]{images/inheritedButton}
\fi
\end{center}
\caption{Property panel showing YoungsModulus as inherited (left) and 
explicitly set (right).}%
\label{inheritedButtonFig}
\end{figure}

\subsection{Render properties}

Render properties are associated with any component that is
renderable. They are defined in the class 
\javaclass[maspack.render]{RenderProps}. 
Because of their complexity, they are adjusted
through a separate panel from the standard property panel.

To adjust the property panel for a set of components, select the components
in question, using either the viewer window or navigation panel, and then right 
click in either the viewer or the navigation panel. Several options may appear
in the context menu:

\begin{description}

\item[Edit render props]\mbox{}

This will create a special property panel allowing the render properties for
the selected components to be set (see Section \ref{renderPropSettingsSec}
and Figure \ref{renderpropsFig}).

\item[Clear render props]\mbox{}

This will actually remove the render properties
from the selected components (i.e., their render properties will be
set to {\tt null}).  Nominally, this means that the components will not be
rendered, {\it unless} their parents take responsibility for rendering
children without render properties. The latter behavior is common for
lists of particles, springs, finite elements, etc., in order to
avoid the need for defining render properties in a large number
of objects.

\item[Set visible]\mbox{}

This option will appear if any of the selected objects are
invisible. Selecting it will set the render properties so
that all components are visible.

\item[Set invisible]\mbox{}

This option will appear if any of the selected objects are
visible. Selecting it will set the render properties so
that all components are invisible.

\end{description}

\subsubsection{Render property settings}
\label{renderPropSettingsSec}

\begin{figure}[h]
\begin{center}
\iflatexml
\includegraphics[]{images/renderProps}
\else
\includegraphics[width=3in]{images/renderProps}
\fi
\end{center}
\caption{A typical panel for adjusting render properties.}%
\label{renderpropsFig}
\end{figure}

There are a large number of render property settings. Loosely
speaking, they are divided into generic settings, along with those
related to faces, lines, and points. How these are used depends on
what is being rendered. Mesh rendering typically uses the face
settings, along with the line settings to render edges if the
{\tt drawEdges} property is set {\tt true}.  Line settings are also used for
rendering axial springs and the edges of FEM elements.  Point settings
are used for rendering any subclass of Point, including Particle and
FemNode. 

Not all render properties may appear in a render panel; usually, only
those properties relevant to the selected components will be
presented.

\begin{description}

\item[Generic properties:]
\hfil \\
\begin{description}
\item[visible:]
Whether or not the component is visible.
\item[alpha:]
The transparency for polygonal faces (range 0 to 1. Default is 1, for
opaque).
\item[shading:] 
How polygons are shaded ({\tt FLAT}, {\tt SMOOTH},
{\tt METAL} and {\tt NONE}).  For viewer implementations there may be no
difference between {\tt SMOOTH} and {\tt METAL}.
\item[shininess:]
Shininess parameter for polygons (range 0 to 128). Default is 32.
\item[specular:]
If not {\tt null}, specifies the specular reflectance color.
\end{description}

\item[Face related properties:]
\hfil \\
\begin{description}
\item[faceStyle:]
Which polygonal faces are drawn ({\tt FRONT}, {\tt BACK},
{\tt FRONT\_AND\_BACK}, {\tt NONE}).
\item[faceColor:] 
Color used for drawing faces.
\item[backColor:]
Color used for drawing backs of faces. If null, {\tt faceColor} is used.
\item[drawEdges:] 	
If true, face edgesof the polygons are drawn explicitly.
\end{description}

\item[Texture mapping properties:]
\hfil \\
\begin{description}
\item[colorMap:]
If not {\tt null}, specifies the image source file and properties
for color mapping.
\item[normalMap:]
If not {\tt null}, specifies the image source file and properties
for normal mapping.
\item[bumpMap:]
If not {\tt null}, specifies the image source file and properties
for bump mapping.
\end{description}

\item[Edge related properties:]
\hfil \\
\begin{description}
\item[edgeColor:]
The color for edges.
\item[edgeWidth:]
Edge width in pixels.
\end{description}

\item[Line related properties:]
\hfil \\
\begin{description}
\item[lineStyle:] 
How lines are drawn ({\tt CYLINDER}, {\tt LINE}, or {\tt SPINDLE}).
\item[lineColor:]
The color for lines.
\item[lineWidth:]
Line width in pixels when {\tt LINE} style is selected.
\item[lineRadius:]
Cylinder radius when {\tt CYLINDER} or {\tt SPINDLE} style is selected.
\end{description}

\item[Point related properties:]
\hfil \\
\begin{description}
\item[pointStyle:] 
How points are drawn ({\tt SPHERE} or {\tt POINT}).
\item[pointColor:] 
The color for points.
\item[pointSize:] 
Point size in pixels when {\tt POINT} style is selected.
\item[pointRadius:] 	
Sphere radius used when {\tt SPHERE} style is selected.
\end{description}

\end{description}

A typical panel for editing render properties is shown in Figure
\ref{renderpropsFig}. Texture mapping properties, if present, are
normally hidden by default and can be exposed by clicking on the {\sf
expand...} button.

\section{The Timeline}
\label{TimelineSec}

The {\it timeline} is a panel that provides ``play'' controls for
starting and stopping the simulation, and allows the user to
graphically arrange temporal sequences of probes and waypoints to
control and monitor the simulation. If not initially visible, its
visibility can be toggled by hitting the `{\tt t}' key from within the
viewer (Section \ref{keyShortcutsSec}).

\subsection{Probes and waypoints}
\label{ProbesAndWaypoints:sec}

ArtiSynth allows models to connect to special components, known as
{\it probes}, which can either supply input values or monitor output
values over time as the simulation proceeds. Probes attached to
simulation inputs are known as {\it input probes} (class
\javaclass[artisynth.core.probes]{InputProbe}), while those attached
to outputs are known as {\it output probes} (class
\javaclass[artisynth.core.probes]{OutputProbe}).  Each probe has a
{\it start time} and a {\it stop time}, and implements an
\javamethodAlt{artisynth.core.probes.Probe.apply()}{apply(t0,t1)} method
that supplies (or collects) data for the simulation step between time
{\tt t0} and {\tt t1}.  Probes are described in more detail, along
with specifics about how to code them into applications, in the
``Simulation Control'' chapter of the
\artisynthManual{modelguide}{ArtiSynth Modeling Guide}.

The most commonly used probe subclasses are
\javaclass[artisynth.core.probes]{NumericInputProbe} and
\javaclass[artisynth.core.probes]{NumericOutputProbe}, each of which
is associated with a vector of floating point values that are
interpolated over time. This data is usually connected to various
model component properties, and used to either set (for input probes)
or collect (for output probes) the values of those properties. The
size of the vector is known as the probe's {\it vector size} and
matches the properties that the probe is connected to. For example, a
probe controlling a single muscle excitation value will have a vector
size of one, whereas a probe collecting the 3D velocity of a point
will have a vector size of three.

Within a numeric probe, data is defined by a temporal sequence of {\it
knots points} which give the vector values at prescribed times, with
values in between determined by interpolation (Section
\ref{interpolation:sec}). For input probes, the knot density is often
sparse, whereas for output probes it matches the sample rate at which
data is collected, which is usually the simulation step size.

Input and output probes are arranged and displayed graphically in the
timeline, within a set of {\it tracks} (Section
\ref{probesAndTracks:sec}). Each probe is displayed as a bar within
one of these tracks. The display for numeric probes can also be
expanded to show a graph of the numeric
data \label{numericProbeDisplaysSec}.

ArtiSynth allows models to set temporal {\it waypoints}, which are
designated times at which the model state is saved during
simulation. This allows the simulation to be later reset to that time
without having to recompute the simulation from the beginning.  A
special type of waypoint is known as a {\it breakpoint}, which causes
the simulation to pause when it is reached. The timeline displays the
waypoints, and allows them to be created and edited (Section
\ref{waypointsSec}).

\subsection{Basic timeline structure}

The basic structure of the timeline is shown in 
Figure \ref{timelineFig}.

\begin{figure}[h]
\begin{center}
\iflatexml
\includegraphics[]{images/timeline}
\else
\includegraphics[width=.75\textwidth]{images/timeline}
\fi
\end{center}
\caption{The timeline panel, containing: (A) zoom controls, (B) play
controls, (C) save button, (D) time cursor, (E) toolbar, (F) waypoint
track, (G) input track, (H) output track.}%
\label{timelineFig}
\end{figure}

The {\it toolbar} at the top contains the following widgets:

\begin{description}

\item[Zoom controls]\mbox{}

Shrinks or expands the timescale.

\item[Play controls]\mbox{}

Starts, pauses, or resets the simulation.

\item[Save button]\mbox{}

Saves the data for all output probes with attached files.

\item[Time box]\mbox{}

Shows the current simulation time.

\item[Time step box]\mbox{}

Shows the length of time associated with a ``single step'' command.

\end{description}

\subsubsection{Play controls}
\label{PlayControlsSec}

The play controls are in turn comprised of the following buttons:

\begin{tabular}{l l l}
\iflatexml
\includegraphics{images/reset}
\else
\includegraphics[width=.33in]{images/reset}
\fi
& Reset: &
Resets the simulation to the beginning at time 0.\\
\iflatexml
\includegraphics{images/fastBackward}
\else
\includegraphics[width=.33in]{images/fastBackward}
\fi
& Skip-back: &
Moves the simulation time backward to the
previous valid waypoint (see Section \ref{waypointsSec}).\\
\iflatexml
\includegraphics{images/play}
\else
\includegraphics[width=.33in]{images/play}
\fi
& Play: &
Starts the simulation.\\
\iflatexml
\includegraphics{images/pause}
\else
\includegraphics[width=.33in]{images/pause}
\fi
& Pause: &
Takes the place of the play button and pauses the simulation.\\
\iflatexml
\includegraphics{images/singleStep}
\else
\includegraphics[width=.33in]{images/singleStep}
\fi
& Single-step: &
Advances the simulation by a single step, specified in the
time step box.\\
\iflatexml
\includegraphics{images/fastForward}
\else
\includegraphics[width=.33in]{images/fastForward}
\fi
& Skip-forward: &
Moves the simulation time forward to the next
valid waypoint (see Section \ref{waypointsSec}).
\end{tabular}

%\end{description}

\subsubsection{Tracks}

The timeline proper is divided into a number of tracks. At the top is
the {\it waypoint track}, which is used to arrange waypoints and
breakpoints. Below that are a variable number of {\it input} and {\it
output} tracks, which are used respectively for arranging the input
and output probes.

\subsection{Viewing and setting waypoints}
\label{waypointsSec}

\subsubsection{Waypoints}

Waypoints are arranged along the waypoint track at the top of the
timeline and are indicated by a small rectangular blue box
(Figure \ref{waypointsFig}). A solid box indicates a waypoint that contains a
valid state and thus can be advanced to using the fast forward/backward
buttons.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/waypoints}
\else
\includegraphics[width=0.66\textwidth]{images/waypoints}
\fi
\end{center}
\caption{Waypoints (blue) and breakpoints (red) arranged in the waypoint track.}%
\label{waypointsFig}
\end{figure}

To add a waypoint, right-click on the waypoint track.  A popup menu will
show a number of options, including {\sf Add waypoint here}, which adds a
waypoint at the current location of the time cursor, and {\sf Add
waypoint(s)}, which will bring up a dialog prompting for a specific time
to add a Waypoint. The "Add Waypoint" dialog also contains a {\sf repeat}
field, which will cause additional waypoints to be added with a spacing
indicated by the time value, and an option to create breakpoints instead
of waypoints.

Once created, waypoints can be moved by dragging them. They can also
be deleted by right-clicking on them and selecting the {\sf Delete waypoint}
option.

To delete all the waypoints, select {\sf Delete waypoints}, either
from the main {\sf File} menu, or after right-clicking on the waypoint
track.

\subsubsection{Breakpoints}

Breakpoints are waypoints that also cause the simulation to stop.
They are displayed in red instead of blue.

Breakpoints can be added in the same way as waypoints, i.e., by right
clicking on the waypoint track and selecting {\sf Add breakpoint here} or
{\sf Add waypoint(s)}.

Waypoints can be converted into breakpoints (and vice versa) through
the context menu.

\subsubsection{Saving and loading}

It is possible to save and load waypoints to and from an external
file. The following menu options may be selected to do this, either
from the main {\sf File} menu, or after right-clicking on the waypoint
track:

\begin{description}

\item[Save waypoints as ...] \mbox{}

Brings up a file chooser that allows the user to specify a file for
saving all waypoints and their state data. Clicking {\sf Save As}
completes the operation.

\item[Save waypoints] \mbox{}

If a waypoint file has already been specified using either {\sf Save
waypoints as ...} or {\sf Load waypoints ...}, then all waypoints and
their state data are saved to that file.

\item[Load waypoints ...] \mbox{}

Brings up a file chooser that allows the user to specify a file from
which waypoints and their state data will be loaded. Clicking {\sf
Load} completes the operation.  The new waypoints are added to
any existing ones, but previously waypoints are not deleted. Checks
are made to help ensure that the waypoint data is consistent with the
model's current state.

\item[Reload waypoints] \mbox{}

Identical to {\sf Load waypoints ...}, except that it uses a file that
has already been specified using either {\sf Save waypoints as ...} or
{\sf Load waypoints ...}.

\item[Delete waypoints] \mbox{}

Deletes all waypoints {\it except} the one at time zero.

\end{description}

\begin{sideblock}
Waypoint files are currently stored as binary files. The reason for
this is that the required storage is about 1/2 of that required for
text files, while the writing and parsing times are as much as
$10 \times$ faster.
\end{sideblock}

\subsection{Tracks and probes}
\label{probesAndTracks:sec}

Probes are arranged on tracks located beneath the waypoint track.  Input
probes must be placed on input tracks and output probes must be placed
on output tracks.  Furthermore, probes on the same track are not allowed
to overlap.

\begin{sideblock}
{\bf Note:}\\
In the future, additional restrictions may be placed on
what type of probe can be placed on what track.
\end{sideblock}

Probes can be moved horizontally to different times as well as vertically
onto different tracks.  They can also be stretched by dragging the edges
of the probe and cropped by holding the control key while stretching.

On the left side of the timeline is the track panel, which
contains a number of track control widgets (Figure \ref{trackPanelFig}).

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/trackPanel}
\else
\includegraphics[width=0.66\textwidth]{images/trackPanel}
\fi
\end{center}
\caption{Close up of the track panel, showing: (A) track panel, (B)
expand all button, (C) mute all button, (D) expand button, (E) mute
button.}%
\label{trackPanelFig}
\end{figure}

\subsubsection{Creating, moving, and deleting tracks}

New tracks may be added by right-clicking in the waypoint track and
selecting {\sf Add input track} or {\sf Add output track}. 

The vertical location of a track can be moved by left clicking on it
in the left panel and dragging it up or down to a new location.

A track can be deleted by right-clicking on the track in
the track panel and selecting {\sf Delete track}.

\subsubsection{Muting tracks}

A track can be {\it muted} or {\it unmuted} by clicking on its gray mute button
in the track panel (Figure \ref{trackPanelFig}). All probes on a muted track are
ignored during simulation.

All tracks can be muted, thus disabling all probes, by clicking
on the mute all button in the gray panel above the tracks.

\subsubsection{Expanding tracks}

A track can be {\it expanded} or {\it collapsed} by clicking on its green
expand button in the track panel (Figure \ref{trackPanelFig}). Expanding a track
creates an additional area in which the data associated with the
track's probes may be displayed (see Figure \ref{numericDisplayFig}). The way
in which this data is displayed is probe-specific. Probes containing
numeric data usually show their data graphically, as described in
Section \ref{numericProbeDisplaysSec}.

\subsubsection{Grouping tracks}

Multiple contiguous tracks can be selected by clicking on them while
holding the control key.  Furthermore, they can be {\it grouped} together
or {\it ungrouped} by selecting the appropriate option from the context
menu.  Grouped tracks can be collapsed, moved simultaneously and
muted together.

\subsection{Numeric probe displays}
\label{numericProbeDisplaysSec}

Data associated with numeric probes is displayed as a graph within the
display (Figure \ref{numericDisplayFig}), with each entry in a probe's
data vector drawn as a separate trace.  If the probe's vector size is
greater than one, each trace is drawn using a different color (up to a
limit, after which colors are recycled).

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/numericDisplay}
\else
\includegraphics[width=0.66\textwidth]{images/numericDisplay}
\fi
\end{center}
\caption{Expanded input and output tracks showing numeric data.}%
\label{numericDisplayFig}
\end{figure}

\subsubsection{Setting the range and display properties}

The range and other properties of the display can be set by right
clicking in the display and selecting {\sf Edit range and properties
...}, which creates a dialog that allows these to be adjusted. If the
{\sf autoRanging} property is set to {\tt true}, then the display range
automatically expands as needed to accommodate new data. Display ranges
can also be adjusted to fit the current data by right-clicking in the
display and selecting {\sf Fit ranges to data}.

Large data displays (Section \ref{LargeDisplay:sec}) contain
additional GUI-based features to adjust the display range.

\subsubsection{Visibility control}

As mentioned above, each entry in a numeric probe's data vector is
rendered in a different color (up to a limit).  If the vector size is
large (say more than three or four), or if there is much overlapping
of values, then the result can be difficult to visualize.

To manage this problem, numeric displays provide a {\it legend} tool that
allows the user to control the color, drawing order, and visibility
for each vector entry (Figure \ref{legendFig}).

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/legend}
\else
\includegraphics[width=0.30\textwidth]{images/legend}
\fi
\end{center}
\caption{Legend tool for controlling display visibility.}%
\label{legendFig}
\end{figure}

To create the legend tool, right-click in the display panel and select
{\sf Show legend}. Each row in the legend tool is associated with an
entry in the data vector. The dimensions of the vectors are listed,
followed by the color the entry is drawn in and a toggle controlling
its visibility.  Entries are rendered in bottom-to-top order, so those
at the top will be most visible.

\begin{itemize}

\item To change an entry's color, click the {\sf Set} button, which
will bring up a color menu.

\item To make an entry visible or invisible, use the {\sf Visible}
toggle box.

\item To change the order in which an entry is drawn, click and drag the
entry vertically within the panel.

\end{itemize}

\subsubsection{Editing and scaling data}
\label{EditingData:sec}

As mentioned in Section \ref{ProbesAndWaypoints:sec}, numeric probe data
is described by a temporal sequence of {\it knots}, between which data
is interpolated as described in Section \ref{interpolation:sec}.

Knot points can be made visible or invisible by setting the display's
{\sf knotsVisible} property. This can also be done by right-clicking
in the display and selecting {\sf Show knot points} or {\sf Hide knot
points}. The rendered size of the knot, in pixels, is controlled by
the {\sf knotSize} property.

\begin{sideblock}
Since output probes typically have a very high knot density, their
knots are set to be invisible by default.
\end{sideblock}

For input probes, knot points (when visible) can be edited by moving,
adding, or deleting them:

\begin{itemize}

\item To move a knot point, left click on the knot and drag it.

\item To add a knot point, place the mouse at the desired location
and double left-click.

\item To delete a knot point, right-click on the knot and select 
{\sf Delete knot point}.

\item To edit a knot point data value, right-click on the knot and
select {\sf Edit knot point}.

\end{itemize}

The data for all numeric probes (input or output) can be scaled by
right-clicking in the display and selecting {\sf Scale data ...}.
This allows the user to enter a scaling factor that is applied
uniformly to all the knot points.

\subsubsection{Interpolation control}
\label{interpolation:sec}

The data between knot points in a numeric probe is interpolated, using
one of the interpolation {\it orders} described below, with the
default interpolation order being {\sf Linear}. Linear interpolation
is almost always sufficient for output probes, which typically have a
close spacing between knots that equals the simulation step
size. Input probes, on the other hand, often have a much sparser knot
spacing and so different interpolation orders can be useful.  The
interpolation order of input probes can be set by right-clicking in the
display and selecting the {\sf Interpolation} menu item.  This is
illustrated in Figure \ref{interpolationFig}, which shows two input
probes, one using {\sf Cubic} interpolation and the other using {\sf
Linear} interpolation.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/interpolation}
\else
\includegraphics[width=0.66\textwidth]{images/interpolation}
\fi
\end{center}
\caption{Two expanding tracks with probes showing
cubic interpolation (upper) and linear interpolation (lower).}%
\label{interpolationFig}
\end{figure}

The interpolation options for a numeric probe include:

\begin{description}

\item[Step]\mbox{}

Values are set to the values of the closest previous knots
points.

\item[Linear]\mbox{}

Values are set by linear interpolation of the closest surrounding knot
points.

\item[Cubic]\mbox{}

Values are set by cubic Catmull interpolation between the surrounding
knot points.

\item[CubicStep]\mbox{}

Values are set by cubic Hermite interpolation between the surrounding
knot points, with the slopes at knot points set to zero.

\item[SphericalLinear]\mbox{}

When interpolating quaternions or $4 \times 4$ rigid transformation
matrices, 3D rotation values are set by piecewise spherical linear
interpolation (i.e., "slerp", as described by Shoemake's 1985 SIGGRAPH
paper).  Otherwise, interpolation is linear. Quaternions are assumed
if the vector size of the numeric probe is 4, and $4 \times 4$ rigid
transformation matrices are assumed if the vector size is 16.

\item[SphericalCubic]\mbox{}

When interpolating quaternions or $4 \times 4$ rigid transformation
matrices, 3D rotation values are set by spherical cubic interpolation
(i.e., "slerp", as described by Shoemake's 1985 SIGGRAPH paper).
Otherwise, interpolation is cubic. Quaternions are assumed if the
vector size of the numeric probe is 4, and $4 \times 4$ rigid
transformation matrices are assumed if the vector size is 16.

\end{description}

All of the above interpolation orders are instances of the enumeration
type \javaclass[maspack.interpolation]{Interpolation\$Order}.

\subsubsection{Large displays}

\label{LargeDisplay:sec}

A large display for a numeric probe can be created by right-clicking
on the probe icon and selecting {\sf Large Display}. This will create a
large numeric display in a separate panel, allowing more precise
inspection of data (Figure \ref{largeDisplayFig}).

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/largeDisplay}
\else
\includegraphics[width=0.66\textwidth]{images/largeDisplay}
\fi
\end{center}
\caption{A large display for a numeric probe.}%
\label{largeDisplayFig}
\end{figure}

In addition to the functionality of the smaller displays, large
displays have additional buttons, located across the top, for
controlling the display range and other items. The first four of these
are mode buttons:

\iflatexml
\renewcommand{\arraystretch}{2}%
\begin{tabular}{llp{10in}}
\else
\begin{tabular}{m{.25in}lp{5.25in}}
\fi
\iflatexml
\includegraphics[]{images/SelectArrow}
\else
\includegraphics[height=.25in]{images/SelectArrow}
\fi
&{\sf Select:}&
Places the display into {\it selection} mode, allowing
knots (when visible) to be edited as described in Section \ref{EditingData:sec}.\\
\iflatexml
&\ &\\
\includegraphics[]{images/ZoomIn}
\else
\includegraphics[height=.25in]{images/ZoomIn}
\fi
&{\sf Zoom in:}&
Places the display into {\it zoom in} mode, in which the user
can zoom in by either drag-selecting a region,
or by left clicking on a point of interest.
The mouse wheel can also be used to zoom in or out.\\
\iflatexml
\vspace{\parskip}
\includegraphics[]{images/ZoomOut}
\else
\includegraphics[height=.25in]{images/ZoomOut}
\fi
&{\sf Zoom out:\phantom{M}}&
Places the display into {\it zoom out} mode, in which the user
can zoom out by left clicking on a point of interest.
The mouse wheel can be also used to zoom in or out.\\
\iflatexml
\vspace{\parskip}
\includegraphics[]{images/Hand}
\else
\includegraphics[height=.25in]{images/Hand}
\fi
&{\sf Translate:}&
Places the display into {\it translate} mode, in which the user
can translate a (zoomed-in) display using the left mouse button.
The mouse wheel can also be used to zoom in or out.
\end{tabular}

There are also several additional buttons:

\iflatexml
\begin{tabular}{llp{10in}}
\else
\begin{tabular}{m{.25in}lp{5.25in}}
\fi
\iflatexml
\includegraphics[]{images/UpArrow}
\else
\includegraphics[height=.25in]{images/UpArrow}
\fi
&{\sf Increase y:}&
Increases the vertical y range.\\
\iflatexml
\includegraphics[]{images/DownArrow}
\else
\includegraphics[height=.25in]{images/DownArrow}
\fi
&{\sf Decrease y:}&
Decreases the vertical y range.\\
\iflatexml
\includegraphics[]{images/LeftArrow}
\else
\includegraphics[height=.25in]{images/LeftArrow}
\fi
&{\sf Decrease x:}&
Decreases the horizontal x range.\\
\iflatexml
\includegraphics[]{images/RightArrow}
\else
\includegraphics[height=.25in]{images/RightArrow}
\fi
&{\sf Increase x:}&
Increases the horizontal x range.\\
\iflatexml
\includegraphics{images/FitRange}
\else
\includegraphics[height=.25in]{images/FitRange}
\fi
&{\sf Fit Range:}&
Fits the vertical and horizontal ranges to the current data.\\
\iflatexml
\includegraphics{images/Grid}
\else
\includegraphics[height=.25in]{images/Grid}
\fi
&{\sf Grid:}&
Enables or disables visibility of a grid that aligns with the
x and y axis tick marks.\\
\iflatexml
\includegraphics{images/AutoRange}
\else
\includegraphics[height=.25in]{images/AutoRange}
\fi
&{\sf Auto range:}&
Enables or disables {\it auto-ranging}, in which the y axis
is automatically adjusted to fit new data.
\end{tabular}

\iflatexml
\renewcommand{\arraystretch}{1}%
\fi

\subsubsection{Cloning displays and exporting plots}

Large data displays can be {\it cloned} by right-clicking in the
display and selecting {\sf Clone display}. This creates a duplicate
display (Figure \ref{clonedDisplay:fig}) containing a copy of all the
data currently in the probe.  However, the duplicate display is not
attached to the probe, and so the data does not change when the probe
is reset or additional data is added to the probe. This is useful for
comparing outputs between different simulations.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/clonedDisplay}
\else
\includegraphics[width=0.66\textwidth]{images/clonedDisplay}
\fi
\end{center}
\caption{A large display of an output probe and its clone.}%
\label{clonedDisplay:fig}
\end{figure}

In addition, it is possible to export a large display's plot to an
image file. Right-click in the display, choose {\sf Export image as
...}, and enter the desired file name and file type in the chooser.
The file's type is indicated by its extension. A range of image file
types are supported, including JPEG ({\tt .jpg, .jpeg}), PNG ({\tt
.png}), scalable vector graphics ({\tt .svg}), and encapsulated
PostScript ({\tt .eps}).

\section{Saving and Loading Probes}
\label{savingLoadingProbes:sec}

\subsection{Saving and loading probe data}
\label{savingLoadingProbeData:sec}

Each ArtiSynth probe can be associated with an {\it attached file} to
(or from) which its data can be saved (or loaded).  The attached file
is specified by the probe's {\sf attachedFile} property, which is a
string giving the file's path name. An absolute path locates the file
relative to the system root directory, while a relative path locates
it relative to the current value of ArtiSynth's working
directory (Section \ref{workingDir:sec}). 
If the {\sf attachedFile} property is {\tt null},
then the probe does not have an attached file.

For numeric probes, the file format used to save and load data is
described in the ``Data file format'' subsection of the ``Simulation
Control'' chapter of the \artisynthManual{modelguide}{ArtiSynth
Modeling Guide}.

Data for an individual probe can be saved or loaded by first selecting
it (either within the navigation panel or by left-clicking on its
timeline display bar), and then right-clicking and choosing
one of the following options from the resulting pull-down menu:

\begin{description}

\item[Save data]\mbox{}

If the probe has an attached file, saves its data to that file.

\item[Save data as ...]\mbox{}

Brings up a file chooser allowing the user to specify an attached file
for the probe. Clicking the {\sf Save As} button then sets the
attached file and saves the probe's data in it. The probe's {\sf
attachedFile} property will be set to a relative path name if the file
is located beneath the current ArtiSynth working directory (Section
\ref{workingDir:sec}), and an absolute path name otherwise.

\item[Load data]\mbox{}

If the probe has an attached file, loads its data from that file.

\item[Load data from ...]\mbox{}

Brings up a file chooser allowing the user to specify an attached file
for the probe. Clicking the {\sf Load} button then sets the attached
file and loads the probe's data from it. The probe's {\sf
attachedFile} property will be set to a relative path name if the file
is located beneath the current ArtiSynth working directory, and an
absolute path name otherwise.

\end{description}

In addition, data can be saved for {\it all} outputs probes that have attached
files by either selecting {\sf Save output probe data} from the ArtiSynth
{\sf File} menu, or by clicking on the timeline's {\sf save} button
(C in Figure \ref{timelineFig}).

\subsection{Exporting numeric probe data}

The data associated with a numeric probe can also be exported to
either a CSV file ({\tt *.csv}) or a regular text file ({\tt *.txt}).

Each line in the file describes the numeric data associated with one
of the probe's knot points, and consists simply of a sequence of $n$
numbers, where $n$ is the probe's vector size. For CSV files, the
numbers are separated by commas, while for text files they are
separated by spaces. If ``include time data'' is selected in the
export dialog (see below), then the knot's time value is also included
at the beginning of the line, so that the complete sequence includes
$n+1$ numbers.

\begin{sideblock}
The time values exported with a probe are {\it probe relative}, so
that $t = 0$ corresponds to the probe's start time and any scaling
is ignored.
\end{sideblock}

To export a probe's data, first select the probe (either within the
navigation panel or by left-clicking on its timeline display bar), and
then right-click and choose {\sf Export data as ...}  from the
resulting pull-down menu.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/exportProbeDialog}
\else
\includegraphics[width=.5\textwidth]{images/exportProbeDialog}
\fi
\end{center}
\caption{The export probe data dialog.}%
\label{exportProbeDialog:fig}
\end{figure}

This brings up a dialog (Figure \ref{exportProbeDialog:fig}) that
allows the user to specify the file name and output file type (CSV or
text). It also allows the user to specify export-specific properties,
such as:

\begin{description}

\item[numeric format]\mbox{}

A printf-style format string specifying the formatting for floating
point data.  The default value is {\tt \%g}, which means all numbers
will be written to full precision with a variable length and using
scientific notation if needed. Other allowed formats are described in
the documentation for \javaclass{maspack.util.NumberFormat}.

\item[include time data]\mbox{}

A Boolean value which if {\tt true} indicates that time data should be
included along with the numeric values. Not including time data may be
appropriate when the data is spaced at a known time interval.

\end{description}

\subsection{Saving and loading all probes}
\label{savingAndLoadingProbesSec}

The model's entire configuration of input and output probes can be
saved to (or loaded from) a single file. This file stores, in an ASCII
text format, complete information about each probe, including its
start and stop times, location within the timeline, which model
properties it connects to, the name of its attached file (if any), and
its current data. The file also stores the current waypoint locations,
but does {\it not} store waypoint data.

Once saved, a probe file can be later loaded to reset the entire probe
configuration.

Probes can be saved or loaded by either opening the ArtiSynth {\sf
File} menu, or by right-clicking on the timeline's waypoint track, and
selecting one of the following:

\begin{description}

\item[Save probes as ...]\mbox{}

Brings up a file chooser that allows the user to specify a file for
saving the current probe configuration. Clicking {\sf Save As} 
completes the operation.

\item[Save probes]\mbox{}

If a probe file has already been specified using either {\sf Save
probes as ...} or {\sf Load probes ...}, then the current probe
configuration is saved to that file.

\item[Load probes ...]\mbox{}

Brings up a file chooser that allows the user to specify a file from
which the probe configuration will be loaded. Clicking {\sf Load}
completes the operation.

\end{description}

\section{Adding and Editing Numeric Probes}
\label{AddingAndEditingNumericProbesSec}

Numeric input and output probes can be interactively added to a
simulation. Output probes allow you to record a vector of values
derived from one or more model component properties.  Input probes
allow you to use a vector of input data to drive one or more model
component properties.

\subsection{Adding output probes}

To add a numeric output probe, go to the main
menu and choose {\sf edit > add output probe}. This will create
a numeric output probe editor, as shown in Figure \ref{OutputProbeEditorAFig}.

\begin{figure}[h]
\begin{center}
\iflatexml
\includegraphics[]{images/outputProbeEditorA}
\else
\includegraphics[width=0.80\textwidth]{images/outputProbeEditorA}
\fi
\end{center}
\caption{Probe editor for an uninitialized numeric output probe.}%
\label{OutputProbeEditorAFig}
\end{figure}

The editor contains three main panels:

\begin{itemize}

\item A {\it property panel} at the upper left in which allows you
to add or edit the properties of model components whose values will be used in
computing the final output probe value. Each property is
associated with a component/property widget, which allows you to first
select a component and then choose one of its properties.

\item A {\it formula panel} at the the upper right which allows
you to add or edit formulae which convert the values from
the properties into numeric values for the output probe.

\item A {\it probe property panel} at the bottom which allows properties of
the probe itself to be set.

\end{itemize}

\subsubsection{Creating a simple probe}
\label{simpleOutputProbeSec}

Creating an output probe that simply records the value of a single
numeric property is fairly easy. Starting with the output
probe editor in Figure \ref{OutputProbeEditorAFig}:

\begin{enumerate}

\item Select a component, either externally through the navigation panel
(Section \ref{navPanelSec}), the viewer 
(Section \ref{viewerSelectionSec}), or the selection
display (Section \ref{selectionDisplaySec}), or by entering its path name into the
component/property widget. Once a component is selected,
the left-most ``up'' arrow can be used to select that
component's parent.

\item Select a property for the component from the property
selection box at the right of the component/property widget.

\item Adjust any required properties for the probe itself 
(Section \ref{settingProbePropertiesSec}).

\item Click {\sf Done}.

\end{enumerate}

\subsubsection{General output probes}

In general, output probes define a general map from the numeric values
of n model component properties to a generalized output vector formed by the
concatenation of m-subvectors formed by m formulae, as shown
in Figure \ref{OutputProbeMapFig}. In the simple case of 
Section \ref{simpleOutputProbeSec},
there is a single property, one sub-vector equal to the output
vector, and a formula which is just the property value itself.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/outputProbeMap}
\else
\includegraphics[width=0.66\textwidth]{images/outputProbeMap}
\fi
\end{center}
\caption{General mapping for an output probe.}%
\label{OutputProbeMapFig}
\end{figure}

Each of the n properties has a numeric value which is
represented by a variable $p_i$ and which is a vector of some dimension
(scalars being considered vectors of dimension 1). The dimension of
the $p_i$ depends on the property and is displayed to the right of the
property selection box on the component/property widget.

Each of the m formulae is an arithmetic expression, implemented in
Jython, which may involve one or more of the variables $p_i$. The output
from each formula is itself a vector of dimension $d_j$, which is
displayed at the right of each formula panel. The simplest formula is
just a single variable $p_i$, in which case $d_j$ equals the dimension of
$p_i$. The concatenation of all the output vectors from all the formulae
produces the output vector associated with the probe, which has a
dimension $\sum_m d_j$.

\subsubsection{Using the probe editor}

What the probe editor allows you to do is create the above mentioned
map by selecting the properties of model components, assigning
variable names to them, and creating formulae using these
variables. When all the selected components form a coherent mapping,
the {\sf Done} button will be enabled and the probe can be completed. When
one or more parts of the mapping is unspecified or incomplete, the
associated widgets will be highlighted and the {\sf Done} button will be
disabled.

Extra properties can be added by requesting additional
component/property widgets using the "{\tt +}" button
in the property panel. Similarly,
extra formulae can be requested using
the add button in the formula panel.

Properties and formulas can also be deleted; simply right
click on the associated widget and choose {\sf delete}.

Property variable names appear in a box at the left of the
component/property widget. Variable names can be changed by editing
this box. Name changes will be propagated into the formulae.

In order to streamline the probe creation process, the editor will try
to guess certain desired actions.  In particular, when the user
chooses a property with a given component/property widget for the
first time, the editor assigns a variable name to that property and
creates a formula panel containing that variable. The variable name
and formula panel can be changed if necessary.

\begin{sideblock}
{\bf Note:}\\ 
The selection manager is connected to at most one
component/property widget at a time. The component field for this
widget is indicated with a blue border; external selections will
affect only that widget. Left clicking on a component/property widget
will cause it to be connected to the selection manager.
\end{sideblock}

\subsection{Adding input probes}

To add a numeric input probe, go to the main
menu and choose {\sf edit > add input probe}. This will create
a numeric input probe editor, as shown in Figure \ref{InputProbeEditorAFig}.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/inputProbeEditorA}
\else
\includegraphics[width=0.80\textwidth]{images/inputProbeEditorA}
\fi
\end{center}
\caption{Probe editor for an uninitialized numeric input probe.}%
\label{InputProbeEditorAFig}
\end{figure}

The editor contains three main panels:

\begin{itemize}

\item An {\it input panel} at the upper left which allows you
to add or edit input variables. Each of these variables represents
a sub-vector of the probe's numeric input vector.

\item A {\it formula/property panel} at the the upper right which allows you
to add or edit numeric properties (using component/property widgets),
along with formulae to determine values for these properties based on
the input variables.

\item A {\it probe property panel} at the bottom which allows properties of
the probe itself to be set.

\end{itemize}

\subsubsection{Creating a simple probe}
\label{simpleInputProbeSec}

Creating an input probe that simply sets a single numeric
property from the probe's input vector is fairly easy, and
is exactly analogous to creating a simple output probe
(Section \ref{simpleOutputProbeSec}). Starting with
the input probe editor in Figure \ref{InputProbeEditorAFig}:

\begin{enumerate}

\item Select a component, either externally, or using the
component/property widget.

\item Select a property for the component from the property
selection box at the right of the component/property widget.

\item Adjust any required properties for the probe itself 
(Section \ref{settingProbePropertiesSec}).

\item Click {\sf Done}.

\end{enumerate}

\subsubsection{General input probes}

In general, input probes define a general map from the probe's
input vector (which is subdivided into n input variables
of dimension $d_i$) to the values of m properties, where each
value is determined by an independent formula based
on the input variables (Figure \ref{InputProbeMapFig}).
In the simple case of Section \ref{simpleInputProbeSec},
there is one input variable which equals the input vector,
and it drives a single property using a formula which is
just the value of the input vector.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/inputProbeMap}
\else
\includegraphics[width=0.66\textwidth]{images/inputProbeMap}
\fi
\end{center}
\caption{General mapping for an input probe.}%
\label{InputProbeMapFig}
\end{figure}

Each input variable is a vector of dimension $d_i$ (scalars being
considered vectors of dimension 1), and the sum of all the $d_i$ equals
the dimension of the input vector.

Each of the formulae controlling the properties is an arithmetic
expression, implemented in Jython, which may involve one or more of
the input variables $p_i$. The output from each formula is itself a vector
whose dimension must match the associated numeric property.
The simplest formula is just a single variable $p_i$, in which
case its dimension equals the dimension of $p_i$.

\subsubsection{Using the probe editor}

The probe editor allows you to create the above mentioned
map by creating input variables, selecting properties,
and creating formulae to drive these properties. When all the
selected components form a coherent mapping, the {\sf Done} button will be
enabled and the probe can be completed. When one or more parts of the
mapping is unspecified or incomplete, the associated widgets will be
highlighted and the {\sf Done} button will be disabled.

Extra properties can be added by requesting additional
component/property widgets using the "{\tt +}" button in the
formula/property panel. Similarly, extra input variables can be
requested using the add button in the formula panel.

Properties and input variables can also be deleted; simply right
click on the associated widget and choose {\sf delete}.

Each input variable is associated with a widget containing two text
fields, the left one defining the variable's name and the right one
its dimension.  The name or dimension can be changed by editing these
fields. Changes will be propagated into the formulae; formulae that
are found to be incompatible with the changes will be cleared.

In order to streamline the probe creation process, the editor will try
to guess certain desired actions.  In particular, when the user
chooses a property with a given component/property widget for the
first time, the editor creates an input variable whose dimension
matches the property, and a simple formula consisting solely
of the input variable. The input variable and formula can be changed if
necessary.

\begin{sideblock}
{\bf Note:}\\
The selection manager is connected to at most one
component/property widget at a time. The component field for this
widget is indicated with a blue border; external selections will
affect only that widget. Left clicking on a component property widget
will cause it to be connected to the selection manager.
\end{sideblock}

\subsection{Setting probe properties}
\label{settingProbePropertiesSec}

The lower part of the probe editor contains a set of fields for
editing various probe properties.

\begin{description}

\item[name]\mbox{}

The name of the of the probe.

\item[start time]\mbox{}

Start time for the probe, in seconds.

\item[stop time]\mbox{}

Stop time for the probe, in seconds.

\item[scale]\mbox{}

Specifies the scale $s$ for this probe, which relates the internal probe 
time $t_p$ to the external simulation (or timeline) 
time $t$. If $t_\text{start}$ is the time
at which the probe starts on the timeline, then $t = t_p s + t_\text{start}$.

\item[attached file]\mbox{}

Names the {\it attached file} for this probe, used for
storing the probe's date. See Section \ref{savingLoadingProbeData:sec}.

\item[display range]\mbox{}

Minimum and maximum range values used for the graphical display
of the probe's data. If these values are left blank, then
the range is computed automatically.

\item[update interval]\mbox{}

(Output probes only). A time interval, in seconds, specifying
how often data should be output to the probe. 

\end{description}

\section{Point Tracing}

Tracing can be enabled for individual points within an ArtiSynth
model. This causes the point to remember the path it followed since
tracing was enabled, and to render this within the viewer as strip of
line segments.

Tracing is enabled by setting a point's {\tt tracing} property to 
{\tt true} in the point's property panel (see Section \ref{propertyPanelsSec}).
When enabled, the point keeps a list of all the positions that it has
occupied since since tracing was first enabled, and renders them as a
series of line segments in the viewer.

Disabling the tracing property causes the trace data to be discarded
and it's rendering to be removed.

When tracing is enabled, the point's render properties are expanded to
include line properties. Adjusting these allow the user to control how
the trace path is rendered. When tracing is disabled, these line
properties are removed.

Since a point's render properties are modified when tracing is enabled
or disabled, any existing open rendering property panels for the
point will no longer work correctly. Instead, the panel should be
closed and reopened.

\subsection{Rendering only the trace(s)}

It may be desirable to restrict rendering to view only the traces
paths, perhaps along with a few selected model components. For
instance, this might be necessary when producing graphs for a paper.

An easy way to do this is to edit the render properties for the
desired points, and set the {\tt visible} property to be explicitly
true. Then, edit the render properties for the top-level model in the
scene, and set its {\tt visible} property to be explicitly false.
This will make invisible all model components whose {\tt visible}
property is inherited. Since the traced points were explicitly set to
be visible, they (and their traces) will remain visible. If the points
themselves are rendered as spheres, they can be made to disappear by
setting their {\tt pointStyle} property to {\tt POINT}, or by setting
their {\tt pointRadius} property to something very small.

\section{Making Movies}

ArtiSynth includes a panel to aid in capturing simulations as
movies. This panel is opened from the main viewer window by navigating
through {\sf View > Show movie panel}. When capturing a movie, pictures are
saved to {\tt ARTISYNTH\_HOME/tmp} periodically as frameXXXXX.ext, where
XXXXX represents the sequential number of the frame (with each X
representing a digit), and the .ext represents the file extension
(determined by the {\sf Frame File} selection in the encoder panel). Because
the frame files aren't unique, recordings will overwrite frames from
prior movies, and if {\sf Remove temporary files} is selected, only the final
products are left. When the recording is stopped, these pictures are then
compressed into a movie file using either mencoder, or an internal
algorithm. The resulting movie is saved to the {\tt \$ARTISYNTH\_HOME/tmp} with
the file name specified at the bottom of the recorder panel.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/moviePanel}
\else
\includegraphics[width=0.40\textwidth]{images/moviePanel}
\fi
\end{center}
\caption{Movie options panel (recorder tab).}%
\label{movieOptionsRecorderFig}
\end{figure}

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/moviePanel2}
\else
\includegraphics[width=0.40\textwidth]{images/moviePanel2}
\fi
\end{center}
\caption{Movie options panel (encoder tab).}%
\label{movieOptionsEncoderFig}
\end{figure}

\subsection{Region to capture options}

These options define the area of the desktop recorded. The default
capture area is the main viewer of ArtiSynth. {\sf Viewer} sets the capture
area exclusively and strictly to the main viewer, and excludes the toolbar
and window. This is useful for recording model demonstrations. The
{\sf Window} option includes the main viewer and the toolbar and window
surrounding it. The {\sf Custom} option allows the user to manually set the 
coordinates, width and height of the region to capture through the given
fields.  It also displays the capture frame, which can be stretched and 
moved to adjust what is recorded.

When the {\sf Viewer} mode is selected, there are additional options
available in the {\sf Output Size} section.  This allows you to create
higher (or lower) resolution videos, independent of the viewer's 
visible resolution.  The {\sf \# samples} specifies the size of the
multi-sample buffer, which is used for anti-aliasing.  This is the
only mode that continues to work correctly when a screen-saver
is activated.  

\subsection{Record options}

These options determine how the movie recorder works with ArtiSynth,
and how it deals with the frame files.

\begin{description}

\item[Begin playing on start]\mbox{}

When the {\sf start} button is clicked, the simulation will begin to run.

\item[End playing on stop]\mbox{}

When the {\sf stop} button is clicked, the simulation stops running.

\item[Automatic frame capture]\mbox{}

Frames are automatically captured according to the movie's frame-rate 
while the model is run.  If this is disabled, it is up to the user
to click on the {\sf Frame} button to capture the next frame.

\item[Remove temporary files]\mbox{}

When selected, the temporary frames are deleted after the movie is made.

\item[Save first image]\mbox{}

This saves the first frame taken. These frames are useful for
representing the movie in websites.

\item[Show capture frame]\mbox{}

Opens a transparent window that reveals what will be captured. The window
is stretchable and movable when the capture option is set to {\sf Custom} and
provides a method to graphically modify the capture area's X coordinate,
Y coordinate, width, and height.

\end{description}

\subsection{Output options}

These options control the frequency of the frames and how they are
combined into a movie.

\begin{description}

\item[Frame rate]\mbox{}

This is the number of frames recorded per second of movie.

\item[Speed]\mbox{}

This is the ratio of the movie's speed to reality's speed. While the
demo is recording, the calculations may slow down the simulation, but
the movie will not be affected.

\begin{sideblock}
{\bf Important:}\\
If the {\sf Frame Rate} or {\sf Speed} is set so that the
increments between the frames is smaller than the calculation steps
used in the, then ArtiSynth will decrease the calculation increments
in order to capture the frames, slowing the simulation.
\end{sideblock}

\item[Frame File]\mbox{}

This is the format the frames will be stored in. If the internal
method (see below) is used, then the frames must be stored as jpegs.

\item[Method]\mbox{}

This is the algorithm used to compress the temporary pictures into a movie.

\begin{itemize}

\item {\sf internal} Use ArtiSynth's built in algorithm to compress the
pictures into an animated jpeg.

\item {\sf mencoder} Use Mencoder to compress pictures into a divx movie
(can be played on MediaPlayer with a plugin).

\item {\sf mencoder\_osx} This option is specific for use on MacOS.

\item {\sf ffmpeg} Use the FFMPEG command-line utility to generate
the movie.

\item {\sf animated\_gif} Uses an algorithm built into ArtiSynth to
generate an animated gif.  By hitting the {\sf Customize Method}
button, you can set the number of times to loop (-1 for infinity)
and the frame rate (defaults to capture frame rate).

\item {\sf avconv} Uses the avconv utility that has replaced
FFMPEG on some linux systems to generate the movie.

\end{itemize}

\end{description}

The customize button right of the method box opens a window where the
specific command calling mencoder can be edited. The variables
identified with the '\$' are the input parameters for the mencoder,
and are based on information provided to the movie panel.

\begin{description}

\item[\$FMT]\mbox{}

Controls the format of the frames. Modifying this is the same as
changing {\tt Frame File}.

\item[\$OUT]\mbox{}
 
The name of the output file. Modifying this is the same as
changing the {\tt name} field.

\item[\$FPS]\mbox{}

Determines the frame rate mencoder uses when it compiles the
movie. By default, this is the same as the {\tt Frame Rate} option.

\end{description}

\subsection{Output size options}

These options are only used when the capture area is set to {\sf Viewer} and
control the size of the output video, allowing the contents of the viewer
to be magnified.

\begin{description}

\item[Same to original size]\mbox{}

The output video is created at the original size.

\item[Constrain proportions]\mbox{}

The output video is created with constrained proportions, such that the ratio
between height and width are maintained.

\item[Width]\mbox{}

Defines the width of the output video. 

\item[Height]\mbox{}

Defines the height of the output video. 

\item[\# samples]\mbox{}

Sets the number of samples to use for the multi-sample buffer.  This only
applies in {\sf Viewer} mode, and is used to perform anti-aliasing.

\begin{sideblock}
{\bf Note:} If your movie comes out black or only shows a section of 
the viewer correctly in {\sf Viewer} mode, then it is likely your
graphics card does not support multi-sample buffers.  On machines 
with multiple graphics cards (e.g. laptops with both discrete and
integrated graphics), make sure the java process is set to use
the discrete card.  Otherwise, set {\sf \# samples = 1} to disable
the multi-sample buffer.
\end{sideblock}

\end{description}

\section{Control Panels}

Control panels are essentially custom-built property panels that are
attached to the root model and let the user interactively set or
adjust various properties while the simulation is in progress.
Most of the panels that appear with the various ArtiSynth demos
are in fact control panels specially created for the demo in question.

The properties controlled by a control panel do not need to come from
the same object; instead, they can come from a variety of objects.
However, unlike with property panels, it is not possible (at the time
of this writing) for a control panel widget to control a property across
multiple objects.

\begin{sideblock}
The problem of controlling the same property in multiple objects
may be addressed in future by the introduction of {\it component groups}.
\end{sideblock}

\subsection{Creating control panels}

To create a control panel, select {\sf Edit > Add control panel} from the
ArtiSynth main menu. This will cause a blank control panel to appear.

To add a widget to this panel, right-click inside the the panel and select
{\sf Add widget}. This will cause a widget creation dialog to appear,
as shown in Figure \ref{widgetCreationDialogFig}.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/widgetDialog}
\else
\includegraphics[width=0.66\textwidth]{images/widgetDialog}
\fi
\end{center}
\caption{Widget creation dialog.}%
\label{widgetCreationDialogFig}
\end{figure}

The top-most widget in this dialog is a component/property
selector. The component section is a selection display identical in
function to that described in Section \ref{selectionDisplaySec}: the path of the
most recently selected component is displayed, and its parent may be
selected by clicking on the ``up'' button at the left. If no component
is selected, you will need to select one using the navigation panel or
the viewer.  Once a component is selected, the combination box on the
right will provide a selection of properties that may be selected for
the widget. Once a property is selected, other options in the dialog
may be used to tune the appearance of the widget:

\begin{description}

\item[slider]\mbox{}

Enabled for properties with a scalar numeric value.
Setting it to true will create a widget with a slider.

\item[range]\mbox{}

Specifies the range for the slider, if one is selected.

\item[labelText]\mbox{}

The name of the widget in the panel. By default, this is the
name of the property.

\item[labelFontColor]\mbox{}

Font color for the widget name. If {\tt null}, then the default color 
is used.

\item[backgroundColor]\mbox{}

Background color for the widget. If {\tt null}, then the default 
background is used.

\end{description}

\subsubsection{Composite property widgets}

A \javaclass[maspack.properties]{CompositeProperty} is a Property which contains
sub-properties. If a composite property is selected, the control panel
will create a {\it composite property widget}, three of which are shown in
Figure \ref{compositePropWidgetsFig}.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/compositePropWidgets}
\else
\includegraphics[width=0.45\textwidth]{images/compositePropWidgets}
\fi
\end{center}
\caption{Composite property widgets.}%
\label{compositePropWidgetsFig}
\end{figure}

Clicking the {\sf set} button of a composite property widget will create
another panel presenting all the sub-properties. The composite
property widget is disabled until this panel is closed.

In some instances, a composite property can be set to {\tt null}.  In such
cases, the widget will provide an additional component, which

\begin{itemize}

\item if the current property value is {\bf not} {\tt null}, will be a 
{\sf clear} button which sets the value to {\tt null} 
(second widget, <Figure \ref{compositePropWidgetsFig}).

\item if the current property value {\bf is} {\tt null}, will be a display label
indicating this fact (third widget, <Figure \ref{compositePropWidgetsFig}).

\end{itemize}

\subsubsection{Widgets for sub-properties}

It is possible to attach widgets to the sub-properties of a 
composite property, provided that the composite property 
has a non-null value.

In particular, when a non-null composite property is selected from the
component/property widget, the user has the option of either

\begin{itemize}

\item clicking the {\sf Done} button and selecting the composite property,
which will create a composite property widget as described in the
previous section, or

\item selecting one of the composite property's sub-properties.

\end{itemize}

When a non-null composite property is selected, the property's name
will move over into the component field of the component/property
selector, and the combination box will be cleared and reset to allow
the selection of the sub-properties.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/selectingRenderVisible}
\else
\includegraphics[width=0.66\textwidth]{images/selectingRenderVisible}
\fi
\end{center}
\caption{Selecting property renderProps (top), then one of it's 
subproperties (bottom).}%
\label{selectingRenderPropsFig}
\end{figure}

For example, in Figure \ref{selectingRenderPropsFig}, we first select
{\tt renderProps}, which is a composite property of
{\tt models/msmod/particle/2}, and then (in the lower panel) select the
sub-property {\tt visible}.  When {\tt renderProps} is selected, its name is
moved to the component panel, where it appears as

\begin{verbatim}
  models/msmod/particle/2:renderProps
\end{verbatim}

\begin{sideblock}
{\bf Note:}\\ 
The `{\tt :}' character is used to separate components from
properties in component/property paths
\end{sideblock}

\subsection{Editing control panels}

An existing control panel can also be edited. Specifically,

\begin{itemize}

\item Individual widgets can be moved, deleted, or have their properties
set.

\item Separators can be added between widgets.

\item Global aspects of the control panel itself can be set.

\end{itemize}

To edit an individual widget, you first select it by left-clicking on
it. This will cause it to become highlighted. You can then:

\begin{itemize}

\item {\bf Move} the widget by dragging it to a different vertical location
within the panel;

\item {\bf Delete} the widget by right-clicking and choosing {\sf delete};

\item {\bf Set properties} of the widget by right-clicking and choosing
{\sf properties};

\end{itemize}

To add a separator, select a widget above where you want the
separator, right-click and choose {\sf add separator}.

To set global aspects of the control panel itself, right-click
inside the lower-most {\it option pane} (the small panel at the
bottom and that may, in some cases, contain option buttons such as {\sf Close}
or {\sf Done}), and choose from the provided menu.

\subsection{Live updating}

By default, a control panel is set up to update the values of its
widgets every time the viewers are rerendered. This allows one to
observe property values as they evolve in time.

If you do {\it not} want live updating of property values, then you can
disable this by clicking on the {\it live update icon}
\includegraphics{images/liveUpdateIcon}, which is located in the lower left of the
option panel.

\section{Component Editing}
\label{componentEditingSec}

Component editing in ArtiSynth is driven by the current {\it selection
context}: depending on what items are currently selected, different
editing options will appear in the context menu. These options may
allow you to add, edit, or delete components.

\subsection{Generic edit operations}

\subsubsection{Deletion}

A set of selected components can be deleted provided that 

\begin{itemize}

\item their parent components are editable 

\item none of their ancestors are selected

\end{itemize}

If the currently selected components are deletable, then a {\sf delete}
option will appear in the context menu (obtained by right-clicking in
the viewer or navigation panel). Selecting this will delete the
components.

If the selected components are referred to by other components, then
those components will be deleted also. In this case, a dialog will be
presented to the user advising of this fact and requesting
confirmation.

\subsubsection{Duplication}

A set of selected components may be {\it duplicated} provided that

\begin{itemize}

\item their parent components are editable

\item none of their ancestors are selected

\item they implement \javaclass[artisynth.core.modelbase]{CopyableComponent}

\end{itemize}

If the currently selected components are duplicatable, then a
{\sf duplicate} option will appear in the context menu. Selecting this
will enable duplication of the components: the viewer cursor will
change to cross-hairs, and the user may indicate the location for the
duplicated components by left-clicking in the viewer
(see Section \ref{indicatingPositionsSec}).  Duplication may
be canceled by right-clicking.

Sometimes, when the components to be duplicated refer to other
components, those referred components will be duplicated also.  This is
done when the referred components are required.  For example, when
duplicating an \javaclass[artisynth.core.mechmodels]{AxialSpring}, the two
points it is attached to will also be duplicated, because AxialSprings
are not permitted to exist without attached points.  Such cases are
indicated to the user, after the {\sf duplicate} option has been selected,
by expanding the current selection to include all such additional
components.

\subsubsection{Undo}

Many of the operations described here are {\it undoable}, by choosing
the {\sf Undo} option from the {\sf Edit} menu. The menu option will
indicate the name of the operation to be undone. Hitting the `{\tt z}'
key from within the viewer (Section \ref{keyShortcutsSec}) will
also perform undo operations.

\subsection{Editing panels}

Many editing operations involve the creation of {\it editing} panels (such
as Figure \ref{addFemModelPanelFig}, etc.) which persist beyond the invocation of
a context menu. Often, these panels are created {\it exclusively}, so that
only one can be in existence at once.  This is done by having the
panel acquire a lock in the ArtiSynth editing manager. The panels are
not modal, so the user can still interact with the viewer and other
GUI components, but other exclusive editing panels can not be created
until the current one is closed. This avoids problems associated with
having two ``edits'' active on a the model at once. 

If an exclusive editing panel is open, then other exclusive editing
options will still be shown in the context menu but will be disabled.

\subsection{Specifying position, orientation, and scaling}
\label{positionOrientationScalingSec}

Sometimes, an editing panel will allow you to specify the translation
and rotation associated with a
\javaclass[maspack.matrix]{RigidTransform3d}. Typically, this will happen
when there is a need to specify the location of a spatial coordinate
frame, as in the example of Figure \ref{locationPanelFig}. 

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/locationPanel}
\else
\includegraphics[width=0.50\textwidth]{images/locationPanel}
\fi
\end{center}
\caption{Panel for specifying the location of a coordinate frame.}%
\label{locationPanelFig}
\end{figure}

Here, the translation
and rotation correspond to the fields {\sf position} and
{\sf orientation}. The {\sf position} field is straightforward: it is just three
numbers giving the position of the coordinate frame origin with
respect to the base (usually world) coordinates. In Figure \ref{locationPanelFig},
this is the vector (1, 2, 3).

The {\sf orientation} field is more complex. It corresponds to the rotation
of the coordinate frame with respect to base coordinates, and is
represented using an {\it axis-angle} format of four numbers giving the
axis of the rotation, followed by the angle of rotation about this
axis, in degrees.  (This relies on the fact that any 3D rotation can
be specified as a single rotation about a single axis.)  Hence the
numbers

\begin{verbatim}
 0 1 0 60
\end{verbatim}

in Figure \ref{locationPanelFig} correspond to a rotation of 60 degrees about
the y axis. Alternatively, the numbers

\begin{verbatim}
 1 1 0 45
\end{verbatim}

would correspond to a rotation of 45 degrees about the axis (1, 1, 0).
(Note that the axis does not need to be a unit vector.)
Finally, no rotation, or more precisely, the {\it identity} rotation,
is usually represented as

\begin{verbatim}
 1 0 0 0
\end{verbatim}

i.e., {\it zero} rotation about the x-axis. In more general situations,
one may specify not only translation and rotation but also scaling,
corresponding to a more general
\javaclass[maspack.matrix]{AffineTransform3d}. This often occurs when
reading a mesh from a file: one may wish to apply an affine transform
to scale, rotate, and translate the mesh that is been read in.  In
such cases one will also be presented with a {\sf scale} field, which
accepts either a single number (to denote uniform scaling), or three
numbers (to denote non-uniform scaling about the x, y, and z axes).

\subsection{Editing MechModels}

A \javaclass[artisynth.core.mechmodels]{MechModel} is the central ArtiSynth
component for mechanical simulation. It contains sets of mechanical
components, including particles, rigid bodies, axial springs, rigid
body connectors, as well as sub-models including other {\tt MechModels}
and finite element (FEM) models. Most of these components can be added to a
MechModel graphically, as described below.

To add a component to a MechModel, select the MechModel and choose the
appropriate edit action shown in the context menu. A MechModel cannot
be selected in the viewer, but can be selected using the navigation
panel (Figure \ref{navpanelFig}), or by first selecting one of its visible
components in the viewer and navigating up the hierarchy to it using
the {\sf up arrow} of the selection display (Section \ref{selectionDisplaySec}).

\subsubsection{Adding finite element models}

To add a \javaclass[artisynth.core.femmodels]{FemModel} to a MechModel,
select the MechModel and choose {\sf "Add FemModel ..."} in the context
menu.  This will open the editing panel shown in Figure \ref{addFemModelPanelFig},
which allows the user to provide information about the model's
properties and geometry.

Default values are provided for almost all of this information; the
only information that {\it must} be specified by the user is the model's
position (corresponding to the origin of it's volumetric mesh). This
can be done either by left-clicking in the viewer
(Section \ref{indicatingPositionsSec}), or by entering coordinates in the
{\sf position} field of the {\sf Location} subpanel.  Once a position is
specified, a wireframe preview of the FEM appears in the viewer
(Figure \ref{addFemModelPreviewFig}), showing its geometry and allowing it to be
moved or rotated using an attached transformer. The user is then free
to continue editing the properties and geometry information, until the
model is in the desired form, at which point it can be added to the
MechModel by clicking the {\sf Add} button.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/addFemModelPreview}
\else
\includegraphics[width=0.50\textwidth]{images/addFemModelPreview}
\fi
\end{center}
\caption{Wireframe preview of the FEM in the viewer.}%
\label{addFemModelPreviewFig}
\end{figure}

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/addFemModelPanel}
\else
\includegraphics[width=0.50\textwidth]{images/addFemModelPanel}
\fi
\end{center}
\caption{Panel for adding finite element models.}%
\label{addFemModelPanelFig}
\end{figure}

From top to bottom, the FemModel panel contains:

\begin{itemize}

\item An {\it instruction box} containing directions for the user.

\item A {\it General Properties} subpanel, which allows the user to set properties
for the FemModel. For brevity, some of these properties are hidden and can
be expanded by clicking the {\sf more...} button.

\item A {\it Location} subpanel, allowing the position and orientation to be
set manually. The position corresponds to the mesh origin, while the
orientation is a rotation applied to the mesh, specified in
{\it axis-angle} format (see Section \ref{positionOrientationScalingSec}).

\item A {\it Geometry} panel, allowing specification of the mesh geometry type
and various properties specific to this type.  Mesh types currently
supported include Grid, Tube, Torus, Sphere, Extrusion, AnsysMesh,
TetgenMesh and UCDMesh.  For many of these, the associated element
type can also be specified: Tet (tetrahedron), Hex (hexahedron),
QuadTet (quadratic tetrahedron), QuadHex (quadratic hexadredron), and
Wedge.

\item An {\it option} panel, containing the {\sf Add} button, a {\sf Clear} button
which resets the displayed fields to default values, and a {\sf Cancel}
button which closes the panel without adding a FemModel.

\end{itemize}

\subsubsection{Adding rigid bodies}

To add a \javaclass[artisynth.core.mechmodels]{RigidBody} to a MechModel,
select the MechModel and choose {\sf "Add RigidBody ..."} in the context menu to
open an editing panel for rigid bodies, as shown in 
Figure \ref{addRigidBodyPanelFig}.

As with adding FEM models, default values are provided for most
information; the user must only specify the body's position, either by
left-clicking in the viewer (similar to Section \ref{indicatingPositionsSec}), 
or by entering
coordinates in the {\sf position} field of the {\sf Location} subpanel.  Once
a position is specified, a wireframe preview of the rigid body appears
in the viewer (Figure \ref{addFemModelPreviewFig}), showing its geometry and
allowing it to be moved or rotated using an attached transformer. The
user is then free to continue editing the properties, geometry and
inertia information, until the model is in the desired form, at which
point it can be added to the MechModel by clicking the {\sf Add} button.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/addRigidBodyPanel}
\else
\includegraphics[width=0.50\textwidth]{images/addRigidBodyPanel}
\fi
\end{center}
\caption{Panel for adding RigidBodies.}%
\label{addRigidBodyPanelFig}
\end{figure}

From top to bottom, the {\sf Add RigidBody} panel contains:

\begin{itemize}

\item An {\it instruction box} containing directions for the user.

\item A {\it General Properties} subpanel, which allows the user to set properties
for the body. For brevity, some of these properties are hidden;
the panel can be expanded by clicking the {\sf more...} button.

\item A {\it Location} subpanel, allowing the position and orientation of the
body's coordinate system to be set manually. Position is specified as
a three-vector, while the orientation is given as a rotation in
{\it axis-angle} format (see Section \ref{positionOrientationScalingSec}).

\item A {\it Geometry And Inertia} subpanel, which allows the user to specify the
body's surface mesh geometry and spatial inertia, using the
same type of panel as described in Section \ref{geometryAndInertiaSec}.

\item An {\it option} panel, containing the {\sf Add} button, a {\sf Clear} button
which resets the displayed fields to default values, and a {\sf Cancel}
button which closes the panel without adding a rigid body.

\end{itemize}

\subsubsection{Adding frame markers}
\label{addingFrameMarkersSec}

A \javaclass[artisynth.core.mechmodels]{FrameMarker} is a massless
\javaclass[artisynth.core.mechmodels]{Point} attached to a
\javaclass[artisynth.core.mechmodels]{RigidBody}. It can be used for tracing
motions of that body, or as an anchor point for attaching axial
springs or other components.

To add one or more frame markers to the rigid bodies in a MechModel,
you can select either the MechModel, or one of its rigid
bodies, and then choose {\sf "Add FrameMarkers ..."} in the context
menu. This will open a FrameMarker editing panel, as shown in
Figure \ref{addFrameMarkersPanelFig}. While this panel is open, frame markers can
be added by using the viewer and left-clicking the mouse over the
surface mesh of the rigid body at the location where you want the
marker to be placed (see Section \ref{indicatingPositionsSec}). The rigid body in
question must belong to the MechModel that was originally selected; no
marker will be added to bodies that belong to another MechModel or a
MechModel which is a submodel of the current one.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/addFrameMarkersPanel}
\else
\includegraphics[width=0.45\textwidth]{images/addFrameMarkersPanel}
\fi
\end{center}
\caption{Panel for adding frame markers.}%
\label{addFrameMarkersPanelFig}
\end{figure}

From top to bottom, the FrameMarker editing panel contains

\begin{itemize}

\item An {\it Existing frame markers} list, showing all the MechModel's frame
markers (expressed by their path names with respect to the
MechModel). This list is connected to the selection manager and can be
used to select one or more markers.

\item A {\it name} field that allows a name to be specified for the marker.

\item A {\it Default marker properties} panel, which
allows the user to set properties for subsequent FrameMarkers that are added.

\item An {\it instruction box} containing directions for the user.

\item An {\it option} panel, which in this case contains a {\sf Done} button which
the user should click when finished.

\end{itemize}

\subsubsection{Adding particles}

A \javaclass[artisynth.core.mechmodels]{Particle} is a dynamic component,
with mass, derived from \javaclass[artisynth.core.mechmodels]{Point}. It is
usually connected to other components in a model with either axial
springs (Section \ref{addingAxialSpringsSec}) or point-to-point attachments
(Section \ref{particleParticleAttachmentSec}).

To add one or more particles to a MechModel, select the MechModel in
question and choose {\sf "Add Particles ..."} in the context menu. This
will open a Particle editing panel, as shown in
Figure \ref{addParticlesPanelFig}. While this panel is open, a particle can be
added by left-clicking the mouse in the viewer at the location where
you want the particle to be placed, using the {\sf constrain to plane} option if
necessary (see Section \ref{indicatingPositionsSec}).

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/addParticlesPanel}
\else
\includegraphics[width=0.50\textwidth]{images/addParticlesPanel}
\fi
\end{center}
\caption{Panel for adding particles to a MechModel.}%
\label{addParticlesPanelFig}
\end{figure}

From top to bottom, the Particle editing panel contains

\begin{itemize}

\item An {\it Existing particles} list, showing all the MechModel's particles
(expressed by their path names with respect to the MechModel). This
list is connected to the selection manager and can be used to select
one or more particles.

\item A {\it name} field that allows a name to be specified for the particle.

\item A {\it Default particle properties} panel, which allows the user to set
properties for subsequent particles that are added. For brevity, some
of these properties are hidden; the panel can be expanded by clicking
the {\sf more...} button.

\item An {\it instruction box} containing directions for the user.

\item A {\sf constrain to plane} option.

\item An {\it option} panel, which in this case contains a {\sf Done} button which
the user should click when finished.

\end{itemize}

\subsubsection{Adding axial springs and muscles}
\label{addingAxialSpringsSec}

An \javaclass[artisynth.core.mechmodels]{AxialSpring} is a point-to-point
force effector that connects two
\javaclass[artisynth.core.mechmodels]{Point}s and effects a force between
them based on their separating distance. AxialSprings and its
subclasses can be used to implement linear or nonlinear springs, as
well as the subclass \javaclass[artisynth.core.mechmodels]{Muscle} used to
implement two-point muscles.

To add one or more axial springs to a MechModel, select the MechModel in
question and choose {\sf "Add AxialSprings ..."} in the context menu. This
will open an AxialSpring editing panel, as shown in
Figure \ref{addAxialSpringsPanelFig}. While this panel is open, axial springs can
be added by selecting (using the viewer or any other selection
mechanism) the two points to which the spring is attached.  Points may
include frame markers, particles, or FEM nodes.  However, the points
must be contained within the MechModel or one of its submodels.

By default, two points must be selected, in succession, for each axial
spring added. Alternatively, by selecting {\sf add continuously} at the
bottom of the panel, a continuous sequence of springs will be created
whereby the second point selected for a given spring becomes the first
point for the spring following it.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/addAxialSpringsPanel}
\else
\includegraphics[width=0.50\textwidth]{images/addAxialSpringsPanel}
\fi
\end{center}
\caption{Panel for adding axial springs and muscles.}%
\label{addAxialSpringsPanelFig}
\end{figure}

From top to bottom, the AxialSpring editing panel contains

\begin{itemize}

\item An {\it Existing axial springs} list, showing all the MechModel's
springs (expressed by the path names, with respect to the MechModel,
of their points). This list is connected to the selection manager and
can be used to select one or more springs.

\item A {\it name} field that allows a name to be specified for the spring.

\item A {\it Spring type} field that allows a specific subclass of AxialSpring
to be selected.

\item A {\it Default properties} panel, which allows the user to set
properties for subsequent springs that are added. The properties in
question vary depending on the type selected in the {\sf Spring type}
field. For brevity, some properties may be hidden, in which case the
panel can be expanded by clicking the {\sf more...} button.

\item A {\it progress} field displaying the path names of the points
as they are selected.

\item An {\it instruction box} containing directions for the user.

\item An {\sf add continuously} option as described above.

\item An {\it option} panel, containing an {\sf Add/Stop} button which is used
to initiate or stop the addition of springs, and a {\sf Done} button which
the user should click when finished.

\end{itemize}

\subsubsection{Adding rigid body connectors}

A \javaclass[artisynth.core.mechmodels]{BodyConnector} is a component
that implements constraint-based joints between either two rigid bodies, or
between one rigid body and ground. The GUI currently allows two types
of joints to be added: {\it spherical} and {\it revolute}.

To add one or more rigid body connectors to a MechModel, select the
MechModel in question and choose {\sf "Add RigidBodyConnectors ..."} in the
context menu. This will open a RigidBodyConnector editing panel, as
shown in Figure \ref{addRigidBodyConnectorsPanelFig}. While this panel is open, a
connector can be added by selecting in succession (using the viewer or
any other selection mechanism) the rigid bodies associated with
it. For the case of a single rigid body connected to ground, the user clicks 
the {\sf Fixed} button instead of selecting a second body. 

After the bodies have been selected, the connector location must then be
specified by left-clicking in the viewer (Section \ref{indicatingPositionsSec}).
By default, the orientation of the connector is aligned with the world
axes. This can be adjusted later using the dragger fixtures 
(Section \ref{draggerFixturesSec}).

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/addRigidBodyConnectorsPanel}
\else
\includegraphics[width=0.50\textwidth]{images/addRigidBodyConnectorsPanel}
\fi
\end{center}
\caption{Panel for adding rigid body connectors.}%
\label{addRigidBodyConnectorsPanelFig}
\end{figure}

From top to bottom, the RigidBodyConnector editing panel contains

\begin{itemize}

\item An {\it Existing rigid body connectors} list, showing all the MechModel's
connectors (expressed by the path names, with respect to the MechModel,
of their rigid bodies). This list is connected to the selection manager and
can be used to select one or more connectors.

\item A {\it name} field that allows a name to be specified for the connector.

\item A {\it Connector type} field that allows a specific connector
type to be selected.

\item A {\it Default properties} panel, which allows the user to set
properties for subsequent connectors that are added. The properties in
question vary depending on the type selected in the {\sf Connector type}
field. For brevity, some properties may be hidden, in which case the
panel can be expanded by clicking the {\sf more...} button.

\item A {\it progress} field displaying the path names of the rigid bodies
as they are selected.

\item An {\it instruction box} containing directions for the user.

\item An {\it option} panel, containing an {\sf Add/Stop} button which can be used
to initiate or stop the addition of connectors, a {\sf Fixed} button used
to indicate when a rigid body is to be connected to ground, and a
{\sf Done} button which the user should click when finished.

\end{itemize}

\subsubsection{Attaching particles to particles}
\label{particleParticleAttachmentSec}

Within a MechModel, two particles or FEM nodes can be attached
together, resulting in what is essentially a single particle that
combines the dynamics of both original particles. In particular, these
{\it particle attachments} are a convenient way to connect FEM models to
other FEM models or to particles within a MechModel.

To attach particles contained within a MechModel, select the MechModel in
question and choose {\sf "Attach particles ..."} in the context menu. This
will open a ParticleAttachment panel, as shown in
Figure \ref{attachParticlesPanelFig}. While this panel is open, pairs of particles
can be attached by selecting in succession (using the viewer or any
other selection mechanism) the two particles to be connected.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/attachParticlesPanel}
\else
\includegraphics[width=0.40\textwidth]{images/attachParticlesPanel}
\fi
\end{center}
\caption{Panel for attaching particles together.}%
\label{attachParticlesPanelFig}
\end{figure}

From top to bottom, the ParticleAttachment  panel contains

\begin{itemize}

\item An {\it Existing attachments} list, showing all the MechModel's
attachments (expressed by the path names, with respect to the
MechModel, of their particles). This list is connected to the
selection manager and can be used to select one or more attachments.

\item A {\it progress} field displaying the path names of the particles as
they are selected.

\item An {\it instruction box} containing directions for the user.

\item An {\it option} panel, containing an {\sf Attach/Stop} 
button which can be used
to initiate or stop the attachment process, and a {\sf Done} button which
the user should click when finished.

\end{itemize}

\subsubsection{Attaching particles to rigid bodies}
\label{particleRigidBodyAttachSec}

Within a MechModel, particles and FEM nodes can also
be attached to rigid bodies. In particular, this provides a way
to connect FEM models to rigid bodies within a MechModel.

To attach particles to a rigid body, select the rigid body in question
and choose {\sf "Attach particles ..."} in the context menu. This will
open a ParticleRigidBodyAttachment panel, as shown in
Figure \ref{attachParticlesToRigidBodyPanelFig}. While this panel is open,
particles can be attached to the body by selecting them in succession.
By default, the attached particles remain where they are, so that the
attachment point is determined by the current particle location
relative to the rigid body's coordinates. However, this will typically
not coincide with the body's surface mesh.  By selecting {\sf project
points onto body} at the bottom of the panel, attached points will be
relocated to the nearest location on the surface mesh as they are
selected.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/attachParticlesToRigidBodyPanel}
\else
\includegraphics[width=0.40\textwidth]{images/attachParticlesToRigidBodyPanel}
\fi
\end{center}
\caption{Panel for attaching particles to a rigid body.}%
\label{attachParticlesToRigidBodyPanelFig}
\end{figure}

From top to bottom, the ParticleRigidBodyAttachment panel contains

\begin{itemize}

\item An {\it Existing attachments} list, showing all the MechModel's particle
to rigid body attachments (expressed by the path names, with respect
to the MechModel, of the particles and the bodies). This list is
connected to the selection manager and can be used to select one or
more attachments.

\item A {\it progress} field displaying the path names of the particles as
they are selected.

\item A {\sf project points onto body} field, described above.

\item An {\it instruction box} containing directions for the user.

\item An {\it option} panel, containing an {\sf Attach/Stop} button 
which can be used
to initiate or stop the attachment process, and a {\sf Done} button which
the user should click when finished.

\end{itemize}

\subsubsection{Collision handling}

\begin{figure}[h]
\begin{center}
\iflatexml
\includegraphics[]{images/setDefaultCollisionsDialog}
\else
\includegraphics[width=0.40\textwidth]{images/setDefaultCollisionsDialog}
\fi
\end{center}
\caption{Dialog for setting default collision behavior in a MechModel.}%
\label{setDefaultCollisionsDialogFig}
\end{figure}

\begin{figure}[h]
\begin{center}
\iflatexml
\includegraphics[]{images/setCollisionsDialog}
\else
\includegraphics[width=0.30\textwidth]{images/setCollisionsDialog}
\fi
\end{center}
\caption{Dialog for setting collision behavior between bodies.}%
\label{setCollisionsDialogFig}
\end{figure}

In ArtiSynth, collision detection and handling can be enabled between
rigid bodies (such as
\javaclass[artisynth.core.mechmodels]{RigidBody}), deformable bodies
(such as \javaclass[artisynth.core.femmodels]{FemModel3d}), and more
generally any body that implements the interface
\javaclass[artisynth.core.mechmodels]{Collidable}.  Self intersection
is not directly supported, but is indirectly supported for compound
deformable bodies that contain sub-collidable components. For example,
an FEM model is a compound collidable that may contain multiple
surface meshes, some of which can be made to collide with each other.
For more details on collision handling, see the ``Collision Handling''
section of the
\artisynthManual{modelguide}{ArtiSynth Modeling Guide}.

The collision response between any two pairs of bodies is determined
by a \javaclass[artisynth.core.mechmodels]{CollisionBehavior}
component, which contains various properties controlling collision
interactions. Two of these can be directly modified from the GUI:

\begin{description}

\item[enabled]\mbox{}

whether or not collisions are enabled;

\item[friction]\mbox{}

the friction coefficient if collisions are enabled.	

\end{description}

Collisions handling is managed by
a \javaclass[artisynth.core.mechmodels]{CollisionManager} component
within each {\tt MechModel}.  Each {\tt MechModel} provides four
default behaviors that determine the default collision response for
(a) rigid body pairs, (b) rigid-deformable body pairs, (c) deformable
body pairs, and (d) deformable self-intersection. In addition to
these, {\it override} collision behaviors can be specified for any
pairs of bodies.  In situations where a {\tt MechModel} contains
sub-{\tt MechModel}s, then the collision behavior for any pair of
collidables is controlled by the lowest {\tt MechModel} in the
hierarchy that contains both.

\begin{figure}[h]
\begin{center}
\iflatexml
\includegraphics[]{images/collisionProperties}
\else
\includegraphics[width=0.50\textwidth]{images/collisionProperties}
\fi
\end{center}
\caption{Property panel for the collision manager.}
\label{collisionProperties:fig}
\end{figure}

There are several ways to edit collision behavior using the GUI.

\begin{itemize}

\item For default behaviors, the {\sf enabled} and {\sf friction}
properties can be edited by selecting the {\tt MechModel} and then
choosing {\sf "Set default collisions ..."} from the context
menu. This will open the dialog shown in Figure
\ref{setDefaultCollisionsDialogFig}, allowing the {\sf enabled}
and {\sf friction} properties to
be adjusted. For the example shown, collisions are enabled between all
rigid bodies, with a friction coefficient of 0.2, and between all
rigid and deformable bodies, with a coefficient of 0.1. Other
collisions are disabled.

\item If a user selects a particular set of rigid and/or deformable
bodies, a specific collision behavior may be established among those
bodies by choosing {\sf "Set collisions ..."} from the context menu.
That will open the dialog shown in Figure
\ref{setCollisionsDialogFig}, allowing the {\sf enabled} and {\sf
friction} properties for this behavior to be set.

\item If a user selects a single deformable body, a specific
self-intersection behavior for that body may be established by selecting
{\sf "Set self collision ..."}.

\item More detailed collision control can be realized by selecting the
{\tt MechModel}'s collision manager in the navigation panel (Section
\ref{navPanelSec}). Choosing {\sf Edit properties ...} or {\sf Edit
render props ...}  from the right context menu then allows other
properties to be set to control either the collision behavior or the
rendering of collisions. A sample property panel is shown in Figure
\ref{collisionProperties:fig}, and these properties are described in
the ``Collision Handling'' section of the
\artisynthManual{modelguide}{ArtiSynth Modeling Guide}.

\item For more fine-grained control, one may also use the navigation
panel to select one or more of the behavior components located under
the collision manager (see Figure
\ref{setCollisionsNavpanel:fig}). The first four of these control the
default behaviors. Other behaviors, if any, are overrides that have
been added either by application code, or through the GUI.  Once
selected, one can choose {\sf Edit properties ...} or {\sf Edit render
props ...}  from the right context menu to edit their properties.  In
the case of override behaviors, the context menu can also be used to
remove them.

\item Finally, all override behaviors in a specific {\tt MechModel}
may be removed by selecting {\sf "Remove collision overrides"}. This
will cause the collision behavior for all bodies to revert to default
values.

\end{itemize}

\begin{figure}[h]
\begin{center}
\iflatexml
\includegraphics[]{images/setCollisionsNavpanel}
\else
\includegraphics[width=0.50\textwidth]{images/setCollisionsNavpanel}
\fi
\end{center}
\caption{Expanded navigation panel showing the collision manager and
individual behavior components for a {\tt MechModel}.}
\label{setCollisionsNavpanel:fig}
\end{figure}

\subsection{Editing rigid bodies}

The GUI provides some ability to edit rigid bodies,
(type \javaclass[artisynth.core.mechmodels]{RigidBody}), 
the most important
of which allows the user to edit its mesh geometry and inertia (see
Section \ref{geometryAndInertiaSec}).  If a rigid body is selected, the context
menu will provide the following options:

\begin{description}

\item[Add FrameMarkers ...]\mbox{}

Allows FrameMarkers to be added to the rigid body 
(see Section \ref{addingFrameMarkersSec}).

\item[Select markers]\mbox{}

Causes all markers attached to the rigid body to be selected.

\item[Save mesh as ...]\mbox{}

Allows the surface mesh to be saved as an Alias Wavefront {\tt .obj} file.

\item[Edit geometry and inertia ...]\mbox{}

Change the mesh geometry and/or inertia 
(see Section \ref{geometryAndInertiaSec}, below).

\item[Attach particles ...]\mbox{}

Allows particles to be attached to the rigid body 
(see Section \ref{particleRigidBodyAttachSec}).

\end{description}

\subsubsection{Geometry and inertia}
\label{geometryAndInertiaSec}

Choosing {\sf "Edit geometry and inertia ..."} in the context menu for
a rigid body opens a geometry and inertia panel, as shown in
Figure \ref{geometryAndInertiaPanelFig}.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/geometryAndInertiaPanel}
\else
\includegraphics[width=0.50\textwidth]{images/geometryAndInertiaPanel}
\fi
\end{center}
\caption{Panel for editing geometry and inertia.}%
\label{geometryAndInertiaPanelFig}
\end{figure}

The upper part of the panel allows the user to set the mesh geometry,
according to a type specified by the {\sf geometry type} field. Changing
the geometry type changes the panel to include fields for setting
parameters appropriate to the type. Currently supported types include:

\begin{description}

\item[Box]\mbox{}

An axis-aligned box, centered with respect to body coordinates, with
the x, y, and z widths set by three numbers in a {\sf widths} field.

\item[Sphere]\mbox{}

A sphere, centered with respect to body coordinates, with
the radius and the number of vertical mesh slices given
by fields {\sf radius} and {\sf slices}.

\item[Mesh]\mbox{}
 A mesh read in from an Alias Wavefront {\tt .obj} file, whose name
is specified by a {\sf file name} field. The read mesh can also be scaled,
offset, and rotated using information provided by {\sf scale}, {\sf offset},
and {\sf rotation} fields (see Section \ref{positionOrientationScalingSec}). 
The {\sf COM}
button causes the mesh to be offset so that its center of mass
(assuming uniform density) is coincident with the origin of the body's
coordinate system (also causing the location of the center of mass to
become zero).

\end{description}

\begin{sideblock}
{\bf Note:}\\ 
At present, there appears to be a bug in the code that compute
inertia from geometry, producing small errors in the center of mass
calculation. That means that hitting the {\sf COM} button will not cause
the center of mass to become zero, but instead a small number that
will converge to zero if {\sf COM} is hit repeatedly.
\end{sideblock}

The lower part of the panel sets the body's spatial inertia.
Spatial inertia for a rigid body can be set in three ways,
corresponding to the value of the body's {\tt inertiaMethod} property:

\begin{description}

\item[Density]\mbox{}
 
The spatial inertia is calculated from the density and the surface
mesh geometry, with the assumption that the density is uniform.

\item[Mass]\mbox{}

The spatial inertia is calculated from the mass and the surface
mesh geometry, with the assumption that the density is uniform.
The density is computed by dividing the mass by the mesh volume.

\item[Explicit]\mbox{}

The spatial inertia is explicitly specified by entering
values in the mass, inertia, and center of mass fields. The density is
set to the average value obtained by dividing the mass by the
mesh volume.

\end{description}

The inertia method can be set using the {\sf set inertia by} field.  Four
other fields describe properties associated with the spatial inertia
itself: 

\begin{description}

\item[density]\mbox{}

The mass divided by the volume

\item[mass]\mbox{}

The scale mass of the body

\item[rotational inertia]\mbox{}

The xx, yy, zz, xy, xz, and yz components of the
rotational inertia tensor about the center of mass in body
coordinates

\item[center of mass]\mbox{}

the position of the center of mass
with respect to body coordinates.

\end{description}

Depending on the inertia method, the contents of these fields are
either set by the user or updated automatically.

\subsection{Editing FEM models}

The GUI also provides some ability to edit FEM models
(type \javaclass[artisynth.core.femmodels]{FemModel3d}).
If an FEM
model is selected, the context menu will provide the following
options:

\begin{description}

\item[Add FemMarkers ...]\mbox{}

Allows the user to add marker points to the FEM, as described in
Section \ref{addingFemMarkersSec}.

\item[Rebuild surface mesh]\mbox{}
 Rebuilds the surface mesh for the FEM. The
surface mesh is computed automatically from the faces of all the
elements, with inside faces being removed. Also, any elements which
are fully or partly obscured by an active clipping plane are removed
from the calculation, making it possible to create "partial" surface
meshes that provide a cutaway view of the model.

\item[Save surface mesh ...]\mbox{}

Allows the current surface mesh to be saved to an Alias Wavefront {\tt .obj} file.

\item[Save mesh as ANSYS file ...]\mbox{}

Allows the FEM volumetric mesh to be saved using the ANSYS file format.

\end{description}

\subsubsection{Adding FEM markers}
\label{addingFemMarkersSec}

A \javaclass[artisynth.core.femmodels]{FemMarker} is a massless 
\javaclass[artisynth.core.mechmodels]{Point} attached to a
specific \javaclass[artisynth.core.femmodels]{FemElement3d}. 
It can be used for tracing motions within that element,
or as an anchor point for attaching axial
springs or other components. It is analogous to 
a \javaclass[artisynth.core.mechmodels]{FrameMarker} for
FEM elements.

To add one or more markers to an FEM model, you can select the FEM
model in question and then choose {\sf "Add FemMarkers ..."} in the context
menu. This will open a FemMarker editing panel, as shown in
Figure \ref{addFemMarkersPanelFig}. While this panel is open, FEM markers can be
added by left-clicking the mouse in the viewer over the location where
you want the marker placed, using the {\sf constrain to plane} option if
necessary (see Section \ref{indicatingPositionsSec}). 
An FEM marker is then created
and attached to the nearest element in the FEM. If the marker position
is outside the FEM, it is projected onto the closest point on the FEM
surface.

In addition, the button {\sf Add Amira Landmarks} allows a user to add a
set of markers based on locations in an Amira landmark file.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/addFemMarkersPanel}
\else
\includegraphics[width=0.40\textwidth]{images/addFemMarkersPanel}
\fi
\end{center}
\caption{Panel for adding markers to an FEM model.}%
\label{addFemMarkersPanelFig}
\end{figure}

From top to bottom, the FemMarker editing panel contains

\begin{itemize}

\item An {\it Existing markers} list, showing all the FEM's frame
markers (expressed by their path names with respect to the
FEM). This list is connected to the selection manager and can be
used to select one or more markers.

\item A {\it name} field that allows a name to be specified for the marker.

\item A {\it Default marker properties} panel, which
allows the user to set properties for subsequent markers that are added.

\item An {\it instruction box} containing directions for the user.

\item A {\sf constrain to plane} option.

\item An {\it option} panel, containing an {\sf Add Amira Landmarks} button,
described above, and a {\sf Done} button which
the user should click when finished.

\end{itemize}

\subsubsection{Adding muscle bundles}

\javaclass[artisynth.core.femmodels]{FemMuscleModel} is a subclass of
\javaclass[artisynth.core.femmodels]{FemModel3d} that supports muscle
activation. A FemMuscleModel may contain muscle bundles (type
\javaclass[artisynth.core.femmodels]{MuscleBundle}), each of which is
composed of {\it fibres} and {\it elements}.  The fibres are two-point muscles
connecting nodes or markers within the FEM model, with activation
provided by forces acting directly on the fibre end points.  The
elements are a set of references to existing elements within the FEM
model, each combined with an activation direction. Each element
reference within the bundle provides muscle activation behavior by
superimposing a transversely isotropic material behavior on top of the
underlying element's material behavior.

Activation of a MuscleBundle can be effected by either the fibres {\it or}
the elements, with the latter generally providing a superior
simulation result. By default, the fibres are inactive, and are used
simply to provide a good visual indication of the activation
directions within the model, and a way to automatically compute the
referenced elements and their directions (as described below).  To
make the fibres active, set the bundle's {\sf fibresActive} property to
{\tt true}. Conversely, to make the elements inactive, set the bundle's
{\sf muscleMaterial} property to {\tt InactiveMuscle}.

To add a MuscleBundle to a FemMuscleModel, select the model and then
choose {\sf "Add MuscleBundle ..."} from the context menu.  This will
immediately add a MuscleBundle to the model, and then open a
MuscleFibre editing panel (see Section \ref{addingFibresSec}) to allow the user to
add fibres to the model. The panel also contains two extra fields at
the top: {\sf bundle name}, allowing a name to be specified for the
bundle, and {\sf bundle renderProps}, allowing its render properties to be
adjusted. At present, the panel does not contain a {\sf Cancel} option. To
remove the MuscleBundle, either select and delete it, or choose {\sf "Undo
add MuscleBundle"} from the {\sf Edit} menu.

\subsection{Editing muscle bundles}

Existing muscle bundles can be editing to add or remove fibres or
element references.

\subsubsection{Adding fibres}
\label{addingFibresSec}

Fibres can be added to a MuscleBundle by selecting the bundle and then
choosing {\sf "Edit fibres ..."} from the context menu. This will open
a MuscleFibre editing panel as shown in Figure \ref{addMuscleFibresPanelFig}.

The operation of this panel is essentially identical to
the AxialSpring editing panel described in Section \ref{addingAxialSpringsSec}:
fibres are added by successively selecting the points
(which in this case must be FEM nodes or markers)
which serve as the endpoints for the fibres in question.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/addMuscleFibresPanel}
\else
\includegraphics[width=0.50\textwidth]{images/addMuscleFibresPanel}
\fi
\end{center}
\caption{Panel for adding fibres to a muscle bundle.}%
\label{addMuscleFibresPanelFig}
\end{figure}

The only difference from the AxialSpring panel is that the spring type
is assumed to be a Muscle and there is no option to change this.

\subsubsection{Adding element references}

Elements can be added to a MuscleBundle by selecting the bundle and then
choosing {\sf "Edit elements ..."} from the context menu. This will open a
MuscleElement editing panel as shown in Figure \ref{addMuscleElementsPanelFig}.

The operation of this panel is quite simple: one selects the elements
that one wishes to add, and then clicks on the {\sf Add} button to add
them to the bundle. Elements which are already contained in the bundle
will be excluded. Viewer-based element selection is described
in more detail below.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/addMuscleElementsPanel}
\else
\includegraphics[width=0.50\textwidth]{images/addMuscleElementsPanel}
\fi
\end{center}
\caption{Panel for adding elements to a muscle bundle.}%
\label{addMuscleElementsPanelFig}
\end{figure}

From top to bottom, the MuscleElement editing panel contains

\begin{itemize}

\item A list of element references already associated
with the bundle (expressed by the elements' path names with respect to
the FEM muscle model).  To remove element references from the bundle, one may
select them in this list and then choose {\sf "Delete"} from the
context menu. It should be noted that this deletes the {\it references}
for the elements within the bundle, and not the elements themselves
from the FEM model.

\item Fields {\sf modelElementSize} and {\sf bundleElementSize} which control the
size of the element widgets which are rendered for both the FEM muscle
model and the bundle, as described below.

\item An {\it instruction box} containing directions for the user.

\item An {\it option} panel, containing an {\sf Add} button which adds selected
elements to the bundle, and a {\sf Done} button which the user should
click when finished.

\end{itemize}

Element selection is often done by clicking on an {\it element widget} in
the viewer. An element widget is a simplified solid rendering of an
element's shape, with a size that varies from 0 to 1, with 0 being
invisible and 1 being the full size of the element.  Element widgets
can be rendered for all the elements in an FEM model, with a size
controlled by the model's {\sf elementWidgetSize} property. In addition,
separate widgets can be rendered for the all the elements referenced
by a muscle bundle, with a size controlled by the bundle's
{\sf elementWidgetSize} property. In order to be able to see and select
both the referenced elements in a bundle, and the other
elements in the FEM model, one should set {\sf elementWidgetSize} for the
bundle and the model to values greater than zero, with the former
larger than the latter. Figure \ref{elementWidgetsFig} shows a simple example
where referenced elements in a bundle are rendered using a widget size of
0.6, while the model elements themselves are rendered using
a widget size of 0.5.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/elementWidgets}
\else
\includegraphics[width=0.60\textwidth]{images/elementWidgets}
\fi
\end{center}
\caption{Element widgets rendered for both an FEM model (pink) 
and a muscle bundle (cyan).}%
\label{elementWidgetsFig}
\end{figure}

To facilitate element selection and visualization,
the MuscleElement panel
temporarily sets {\sf elementWidgetSize} to 0.6 for the bundle and 0.5 for
the FEM model. These values can then be adjusted as needed.

\subsubsection{Automatically setting elements and directions}

Since manually selecting elements and specifying their directions for
a muscle bundle can be quite tedious, a number of methods exist to
help do this automatically, using the easier-to-visualize information
supplied by the muscle fibres. From the MuscleBundle context menu, one
may select:

\begin{description}

\item[Compute element directions]\mbox{}

Automatically computes directions for all referenced elements,
using a Delaunay-based interpolation of the directions of the
fibres which are closest to them.

\item[Add elements neat fibres ...]\mbox{}

Automatically adds to the set of referenced elements
all elements whose centers are within
a prescribed distance of one or more of the fibres.

\item[Delete elements]\mbox{}

Deletes all the element references for the bundle.

\end{description}

\subsubsection{Removing fibres and element references}

To remove specific fibres or element references, simply select them
(using any of the selection mechanisms), and the choose {\sf "Delete"}
from the context menu.

\subsection{Editing muscle exciters}

A \javaclass[artisynth.core.mechmodels]{MuscleExciter} is a component that
allows muscle excitation signals to be distributed to a set of target
\javaclass[artisynth.core.mechmodels]{ExcitationComponent}s.  Excitation
components include anything that can receive a muscle excitation, including
point-to-point muscles, muscle bundles, and other muscle exciters.
The purpose of a muscle exciter is to facilitate grouping so that one
excitation signal can drive a number of underlying components.
They can be optionally added to both MechModels and FemMuscleModels,
where they are stored in a component list called {\tt exciters}. 

The GUI provides the ability to edit the targets associated with a
given exciter. To do this, select the exciter in question, and then
choose {\sf "Edit targets ..."} in the context menu. This will open an
ExcitationTarget panel, as shown in Figure \ref{excitationTargetPanelFig}.

To add a new excitation target, select the desired excitation
component (using any of the selection mechanisms), and it will be
added to the list of existing targets. Each target is also associated
with a gain, by which the excitation signal is multiplied as it is
passed on to the target. Gains can be edited using the numeric field
in the list of targets. Finally, to remove a target, simply select it
in the list of targets, and choose {\sf "remove targets"} from the context
menu.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/excitationTargetPanel}
\else
\includegraphics[width=0.40\textwidth]{images/excitationTargetPanel}
\fi
\end{center}
\caption{Panel for editing the targets of a muscle exciter.}%
\label{excitationTargetPanelFig}
\end{figure}

From top to bottom, the ExcitationTarget panel contains

\begin{itemize}

\item An {\it Existing targets} list, showing all the current
targets, allowing them to be selected for removal or their gains to be edited.

\item An {\it instruction box} containing directions for the user.

\item An {\it option} panel, containing an {\sf Add/Stop} button which can be used
to initiate or stop the adding of targets, and a {\sf Done} button which
the user should click when finished.

\end{itemize}

\subsection{Editing root models}

Some very limited graphical editing is available for RootModels.  It
is possible to add a MechModel to the RootModel, by selecting the
RootModel and then choosing {\sf "Add MechModel ..."} in the context
menu. This brings up a MechModel editing panel as shown in
Figure \ref{addMechModelPanelFig}.

\begin{figure}
\begin{center}
\iflatexml
\includegraphics[]{images/addMechModelPanel}
\else
\includegraphics[width=0.50\textwidth]{images/addMechModelPanel}
\fi
\end{center}
\caption{Panel for adding a MechModel to a RootModel.}%
\label{addMechModelPanelFig}
\end{figure}

The panel is quite simple: you edit the MechModel properties to the
appropriate settings, click the {\sf Add} button, and a new MechModel is
added. However, this is of limited use, since normally only one
MechModel is placed directly under the RootModel, as multiple
MechModels cannot be advanced using the same integrator and must
therefore be completely decoupled.

\section{Customizing the Models Menu}
\label{CustomizingModelsMenu}

The \textsf{Models} menu is automatically created at run-time.  By
default, it has the format described in Section \ref{LoadingFromModelsMenu}
However, it is possible to supply an alternative {\sf Models} menu
either of the following command-line parameters:

\begin{description}

\item[-demosFile <filename>]
Specifies a flat list of models to be loaded, using a plain text
format.

\item[-demosMenu <filename>]
Specifies a menu that may contain hierarchies, separators, and icons,
using an XML format.

\end{description}

A description of both file formats are provided in the following sections.

\subsection{Plain text format \label{sec:menu:plaintext}}

In the plain text format, entries are listed as title-class pairs, separated by
whitespace.  Lines beginning with a hash (\#) are ignored.  Titles containing
spaces must be surrounded by quotation marks.  The following is an example:

\begin{lstlisting}[]
# Inverse Demos
HydrostatInvDemo artisynth.models.inversedemos.HydrostatInvDemo
"Tongue tracking" artisynth.models.inversedemos.TongueTip   
\end{lstlisting}

\subsection{XML format \label{sec:menu:xml}}

The XML format was designed to give users more control over the appearance of
the menu.  An XML schema is provided that describes and enforces the required
document structure ({\tt src/artisynth/core/modelmenu/modelmenu.xsd}).  The 
following XML elements are defined:
\medskip

\begin{tabular}{ll}
{\tt ModelMenu:} & the root element of the document\\
{\tt model:} & specifies a model that can be loaded\\
{\tt separator:} & inserts a horizontal line that separates entries\\
{\tt label:} & inserts an inactive text entry\\
{\tt menu:} & creates a sub-menu\\
{\tt package:} & finds and lists all models from a specified Java package\\
{\tt demosFile:} & imports all models from a file in plain text format\\
{\tt history:} & adds a set of recently loaded models\\
{\tt include:} & imports a menu from another XML file\\
{\tt hidden: } & convenience element for hiding menu entries (i.e. commenting
   them out)
\end{tabular}
\medskip

A detailed description of each of the element types and their supported 
attributes is provided in the next sections.  Attributes marked by an asterisk
are required in the element definition.  Some attributes, such as {\tt icon}, 
refer to an external file location.  The parser tries to find included files 
by searching directories in the  following order:
\begin{itemize}
  \setlength{\itemsep}{0pt}
  \item The root directory (i.e. absolute path)
  \item The local directory, relative to the XML file
  \item All directories listed in {\tt ARTISYNTH\_PATH}
\end{itemize}
The first readable file found is used.

\subsubsection{The root element}

The root element encapsulates the entire menu description.  It must make 
reference to the schema for validation purposes.  The following code snippet
can be used as a template for creating a new menu file.
\begin{lstlisting}[][language=XMLMenu,escapechar=\#]
<?xml version="1.0" encoding="UTF-8"?>
<ModelMenu xmlns="http://www.artisynth.org"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.artisynth.org src/artisynth/core/modelmenu/modelmenu.xsd"
   >
      #... contents of menu ...#
</ModelMenu>
\end{lstlisting}

\begin{sideblock}
{\bf Note:}\\
The second value of {\tt schemaLocation} is the location of the schema file, 
which may need to be modified depending on its path relative to the current 
XML file.
\end{sideblock}

\subsubsection{Models}

Individual models are inserted into the menu using a {\tt model} element.
These specify a class to load when the menu entry is selected.  The model
must be a sub-class of \javaclass[artisynth.core.workspace]{RootModel}.  

\noindent \textbf{Attributes:}\\
\begin{tabular}{ll}
   {\tt class*:} & the class to load when the entry is selected\\
   {\tt args:} & command-line style arguments to be passed to the model\\
   {\tt text:} & the text to display in the menu (default: the class name)\\
   {\tt icon:} & filename of an icon (relative or absolute path)\\
   {\tt fontname:} & font family for the displayed text\\
   {\tt fontstyle:} & font style, from \{\quot{}, \quot{bold}, \quot{italic},
      \quot{bold italic}\}\\
   {\tt fontsize:} & font size
\end{tabular}

The following snippet creates a menu entry titled "Muscle Arm", which will
launch the model {\tt FemMuscleArm}.
\begin{lstlisting}[][language=XMLMenu]
   <model class="artisynth.models.femdemos.FemMuscleArm" text="Muscle Arm" />
\end{lstlisting}

\subsubsection{Separators}

A separator is a horizontal line that visually separates menu entries.  It 
can help distinguish groups of related menu items.  The {\tt separator} element
has no attributes.  The following snippet adds a separator line between models
found in the {\tt artisynth.models.femdemos} package and those in 
{\tt artisynth.models.inversedemos}.
\begin{lstlisting}[][language=XMLMenu]
   <package source="artisynth.models.femdemos" />
   <separator/>
   <package source="artisynth.models.inversedemos" />
\end{lstlisting}

\subsubsection{Labels}

Labels are inactive text entries; they cannot be selected in the menu.  They
can be used to label a group of entries.  To help distinguish a label from an
active menu item, it is recommended to set the font style to \quot{italic}.

\noindent \textbf{Attributes:}\\
\begin{tabular}{ll}
   {\tt text*:} & the text to display in the menu\\
   {\tt icon:} & filename of an icon (relative or absolute path)\\
   {\tt fontname:} & font family for the displayed text\\
   {\tt fontstyle:} & font style, from \{\quot{}, \quot{bold}, \quot{italic},
      \quot{bold italic}\}\\
   {\tt fontsize:} & font size
\end{tabular}
\medskip

In the following code snippet, a label is added before the tongue tracking 
models.
\begin{lstlisting}[][language=XMLMenu]
   <label text="Tongue Tracking Models" fontstyle="italic" />
   <model class="artisynth.models.tracker.JawDynamicTongue" />
   <model class="artisynth.models.tracker.JawKinematicTongue" />
\end{lstlisting}

\subsubsection{Sub-menus}

Menu hierarchies can be created using the {\tt menu} element.  Apart from the
root element, this is the only non-empty element type.  It can contain any
number of valid elements apart from the root element.

\noindent \textbf{Attributes:}\\
\begin{tabular}{ll}
   {\tt text*:} & the text to display for the sub-menu\\
   {\tt icon:} & filename of an icon (absolute or relative path)\\
   {\tt fontname:} & font family for the displayed text\\
   {\tt fontstyle:} & font style, from \{\quot{}, \quot{bold}, \quot{italic},
      \quot{bold italic}\}\\
   {\tt fontsize:} & font size
\end{tabular}
\medskip

The following code snippet creates a sub-menu "FEM Models" with a specified
icon, and lists all models found within the {\tt artisynth.models.femdemos} 
package.
\begin{lstlisting}[][language=XMLMenu]
<menu text="FEM Models" icon="resources/icons/FEM.gif">
   <package source="artisynth.models.femdemos" />
</menu>
\end{lstlisting}

\subsubsection{Packages}

The {\tt package} element can be used to include all models belonging to
a particular Java package and its sub-packages.  A base class can also be 
specified so that only models that are instances of that base class are added.
For example to include all models that are sub-classes of {\tt HexTongueDemo}, the
following line can be used:
\begin{lstlisting}[][language=XMLMenu]
   <package source="artisynth.models" base="artisynth.models.femdemos.HexTongueDemo" />
\end{lstlisting}
\medskip

The models can be displayed in either a flat or hierarchical structure.  To
reduce the number of sub-menus, and to shorten some of the displayed text, a 
\quot{compactness} level is introduced.  Illustrative examples for the options
are provided in Figure \ref{fig:packagemenu}.

\begin{figure}[!htb]
\centering
\iflatexml
\newcommand{\menuimage}[1]{\includegraphics{images/menu/#1}}
\else
\newcommand{\menuimage}[1]{\includegraphics[width=2.5in]{images/menu/#1}}
\fi
\setlength{\tabcolsep}{0pt}
\iflatexml
\begin{tabular}{ccc}
\else
\newcolumntype{M}{>{\centering\arraybackslash}m{\dimexpr.4\linewidth-2\tabcolsep}}
\begin{tabular}{cMM}
\fi
\hline
\hline
compact & flat & hierarchical \\
\hline
\iflatexml
0 & \menuimage{f0.png} & \menuimage{h0.png}\\
1 & \menuimage{f1.png} & \menuimage{h1.png}\\
2 & \menuimage{f2.png} & \menuimage{h2.png}\\
\else
%0 & \menuimage{f0.eps} & \menuimage{h0.eps}\\
%1 & \menuimage{f1.eps} & \menuimage{h1.eps}\\
%2 & \menuimage{f2.eps} & \menuimage{h2.eps}\\
\fi
\hline
\end{tabular}
\caption{View options for the XML element {\tt <package source="artisynth" base=%
"HexTongueDemo"/>}} %
\label{fig:packagemenu}
\end{figure}

\noindent \textbf{Attributes:}\\
\begin{tabular}{ll}
   {\tt source*:} & the package to search for models\\
   {\tt base:} & the base class from which all models must inherit 
      (default: {\tt RootModel})\\
   {\tt args:} & command-line style arguments to be passed to the models\\
   {\tt view:} & display format \{\quot{flat}, \quot{hierarchicial}\} (default:
      \quot{hierarchical})\\
   {\tt compact:} & level of compactness \{0, 1, 2\} (default: 0)\\
\iflatexml
    & \begin{tabular}{ll}
\else
    & \begin{tabular}{lp{5in}}
\fi
         0: & A new sub-menu is created for each sub-package (hierarchical),
             displayed text refers to full package.class name relative
             to {\tt source} (flat)\\
         1: & Sub-packages containing a single entity are merged into the
             parent menu (hierarchical), displayed text refers to unique
             part of the package.class name only (flat)\\
         2: & Sub-packages containing a single entity are merged into the
             parent menu (hierarchical) and displayed text refers to the
             class name only (hierarchical/flat)
      \end{tabular}   \\
   {\tt fontname:} & font family for the displayed text\\
   {\tt fontstyle:} & font style, from \{\quot{}, \quot{bold}, \quot{italic},
      \quot{bold italic}\}\\
   {\tt fontsize:}: & font size
\end{tabular}
\medskip

If font information is provided, it is applied to all entries.  
\begin{lstlisting}[][language=XMLMenu]
   <package source="" view="flat" compact="2" fontsize="5"/>
\end{lstlisting}
The previous listing adds every single instance of 
\javaclass[artisynth.core.workspace]{RootModel} found
in the source tree to the menu.  To get the menu to fit on the screen, 
{\tt compact="2"} was used to strip away all package information from the 
displayed text, and a tiny font was applied to all entries.

\begin{sideblock}
{\bf Note:}\\
The {\tt package} element should be used sparingly for two main reasons:
\begin{enumerate}
\item Each element adds to the ArtiSynth start-up time.
\item Not all models are functional.
\end{enumerate}
The reason for the start-up delay is that to populate the menu, the parser 
has to search through the supplied package, create an instance of each class,
and test if it is a sub-class of {\tt base}.  The parser also has no way of 
detecting whether or not a model is functional, so all classes matching the
criteria are added.
\end{sideblock}


\subsubsection{Plain text files}

The XML format supports loading models from a {\tt demosFile} that uses the 
original plain text format.  Plain text files have the advantage of being more 
human-readable, and are easier to edit/comment lines out.  Models are listed
in the current sub-menu.

\noindent \textbf{Attributes:}\\
\begin{tabular}{ll}
   {\tt file*:} & plain text file to load\\
   {\tt fontname:} & font family for the displayed text\\
   {\tt fontstyle:} & font style, from \{\quot{}, \quot{bold}, \quot{italic},
      \quot{bold italic}\}\\
   {\tt fontsize}: & font size
\end{tabular}
\medskip

The following line loads all models from the original default ArtiSynth 
{\rm Models} menu.
\begin{lstlisting}[][language=XMLMenu,escapechar=\#]
   <demosFile file=".demoModels" />
\end{lstlisting}
If font information is provided, it is applied to all model entries that are
created.

\subsubsection{History}

If model history tracking is enabled, then a set of \emph{recent items} can
be added to the menu.  To enable history tracking, pass the following command-%
line parameter to ArtiSynth on load:\\
\hspace{4ex}\textbf{-historyFile <filename>}\\
The {\tt history} element then specifies the number of most recently loaded
models to add to the history menu.

\noindent \textbf{Attributes:}\\
\begin{tabular}{ll}
   {\tt size:} & number of recent models to add (default: "4")\\
   {\tt fontname:} & font family for the displayed text\\
   {\tt fontstyle:} & font style, from \{\quot{}, \quot{bold}, \quot{italic},
      \quot{bold italic}\}\\
   {\tt fontsize:} & font size
\end{tabular}

\subsubsection{Importing other XML files}

To facilitate modularity, the {\tt include} element can be used to import
all menu content from another XML menu file.  All elements contained within
the root element of the included file are inserted into the current sub-menu.

\noindent \textbf{Attributes:}\\
\begin{tabular}{ll}
   {\tt file*:} & XML file to import
\end{tabular}

The following code imports the contents from two different XML menu files,
and separates them with a separator item.
\begin{lstlisting}[][language=XMLMenu,escapechar=\#]
   <include file="demos.xml" />
   <separator/>
   <include file="mymodels.xml" />
\end{lstlisting}

\subsubsection{Hiding elements}

It is often convenient to have the ability to \quot{comment-out} lines in any
kind of coding system: the data remains in the file, but has no effect when 
processed.  The typical method for commenting in XML is to use the 
{\tt <!-- -->} tags.  Unfortunately, this can be messy, and comments cannot
contain other comments.  For this reason, a special {\tt hidden} element was
created. Any entries within a {\tt hidden} element are ignored by the parser.

\begin{lstlisting}[][language=XMLMenu,escapechar=\#]
   <!-- temporarily hide FEM demos -->
   <hidden>
     <!-- All FEM demos -->
     <package source="artisynth.models.femdemos" view="flat"/>
   <hidden/>
\end{lstlisting}

\end{document}
